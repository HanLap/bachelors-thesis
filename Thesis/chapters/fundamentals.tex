\chapter{Fundamentals}
\label{ch:fundamentals}

this chapter lays out the knowledge foundation, required in later sections. First an outline of the applied research process is given. following that, a comprehensive view of the \textsc{CouchEdit} architecture is given. This will be needed later on to understand certain design decisions. Thereafter, a foundation of modeling languages is laid out, as well as some modeling syntaxes. Finally, a summary of related work and their impact on this thesis will be presented. 

\section{Methodology}
As this research strived to develop a new metamodel suitable for the \textsc{CouchEdit} framework, it was conducted in accordance to the Design Science Research (DSR) approach. According to V. Vaishnavi et al. a design science research process consists of five steps \cite{vaishnavi_design_2004}.

\subsection{Problem Awareness}
The first step of a design science research is the identification of existing problems. As specified in \Cref{sec:problem_statement}, it was identified that the current \textsc{CouchEdit} implementation lacks a developer friendly way to configure it for different modeling syntaxes and that it is unclear how a metamodel for this architecture would look like.

\subsection{Suggestion}
With a clear definition of the problem, objectives can be proposed which have to be achieved in order to solve this problem. The first objective of this research is to develop a metamodel for the \textsc{CouchEdit} architecture. To be more precise, a metamodel is to be designed, that can be used to specify model syntax definitions which map concrete graphical syntaxes to Abstract syntax models and is applicable to \textsc{CouchEdit}'s architecture. The second objective is to implement a prototype that provides proof of concept for the applicability of the design metamodel.


\subsection{Development}
The primary goal of a design science research is the development of artifacts.
The first artifact to be developed in this research will be a metamodel, that can be used to define new modeling syntaxes for a relaxed conformance editor and is applicable to \textsc{CouchEdit}'s architecture. The second artifact that is to be developed, is a prototypical code generator that can translate the developed metamodel into a \textsc{CouchEdit} implementation which will be able to process the defined modeling syntax. Furthermore it was decided to implement a simple DSL that eases the process of defining an instance of the given metamodel.

To this end, the first sub step of the development stage is a comprehensive analysis of \textsc{CouchEdit}'s architecture. In his work L. Nachreiner describes in detail, which modeling features the framework covers and how they are implemented \cite{nachreiner_couchedit_2020}. The goal is to develop an approach that can streamline the process of defining modeling syntaxes while adhering to \textsc{CouchEdit}'s specification. Related work defined in \Cref{ch:related_work} serves as a basis from which an initial suitable metamodel can be derived.

in the next sub step, the code generator will be implemented, this is an iterative step. first, an implementation will be developed on the basis of the designed metamodel, this should reveal further requirements imposed by \textsc{CouchEdit}'s architecture (RQ2). The metamodel then has to be adjusted to account for these requirements, which in turn requires changes of the implementation until no further requirements can be deduced. Because of time constraints it is not possible to implement all of the metamodel's features, instead the prototype covers a minimal feature set that still suffices to demonstrate the metamodel's applicability for selected modeling syntaxes.

\subsection{Evaluation}
Now that the desired artifacts are fully developed it has to be evaluated how well they do their designated task. The metamodel as the primary artifact of this research has to be evaluated in terms of its applicability to its designated domain. To this end, the metamodel will be demonstrated on the basis of different modeling syntaxes, this should highlight areas in which the metamodel's design excels, as well as design flaws and limitations (RQ3). If time allows, potential flaws can be addressed by returning back to the development phase and revising the artifacts, otherwise flaws are to be highlighted so that future works can address them.

\subsection{Conclusion}
The conclusion stage marks the end of a DSR and the results are written up. This works written part is composed of this thesis as well as all written source code and documentation.


\section{Modeling Language Fundamentals}
\label{sec:modeling-languages}
This thesis discusses modeling syntaxes and how they can be handled in the \textsc{CouchEdit} architecture. The following chapters will demonstrate the developed artifact with the help of modeling syntax examples. thus the two syntaxes that will be used in this thesis are defined here.

% \subsection{Graphical Language Theory}
\subsection{Petrinets Syntax}
\label{sec:petrinets}
The first modeling syntax introduced are Petrinets. Petrinets are easy to understand and provide simple abstract and concrete syntax. Thus they serve as a suitable tool for explaining concepts in the following chapters. \Cref{fig:petrinets_metamodel} shows the abstract syntax metamodel of the used Petrinets syntax. The Petrinets conceptual representation consists of places and transitions. Places also have a token count. each place can have a variable amount of incoming and outgoing transitions, while transitions can have any amount of incoming and outgoing places. 

\begin{figure}[H]
  \centering
  \includesvg[width=.5\linewidth]{images/"csd - petrinet-metamodel"}
  \caption{Metamodel for a simple Petrinet abstract syntax}
  \label{fig:petrinets_metamodel}
\end{figure}

The graphic primitives, a concrete representation of Petrinets is composed of are listed in \Cref{tab:petri-primitives}. places are usually represented as circles, while transitions are depicted as slender rectangles. The number of small black circles inside a place represent this places token count. Furthermore places and transitions possess a label close to their bounding box, that determines their name. Lastly places and transitions have directed connection lines between them. Each connection points from a place or transition towards an element of the opposite type and represents an outgoing connection for the source element and an incoming connection for the target element. A simple concrete instantiation and its corresponding abstract representation is shown in \Cref{fig:petrinets_example}.

\begin{table}[ht]
  \centering
\begin{tabular}[width=.1\linewidth]{| Sc | Sc | Sc | Sc | Sc |}
  \hline
  Place & Transition & Token & Label & Connection 
  \\
  \hline
  \includegraphics[width=.1\linewidth]{images/"petrinet - place"} 
  & 
  \includegraphics[width=.1\linewidth]{images/"petrinet - transition"} 
  & 
  \includegraphics[width=.1\linewidth]{images/"petrinet - token"}
  & 
  \includegraphics[width=.1\linewidth]{images/"petrinet - label"}
  & 
  \includegraphics[width=.1\linewidth]{images/"petrinet - connection"} 
  \\
  \hline
\end{tabular}
\caption{graphic primitives used to describe Petrinets}
\label{tab:petri-primitives}
\end{table}

\begin{figure}[ht!]
  \centering
  \begin{subfigure}[t]{.3\textwidth}
    \centering
    \includesvg[width=.9\linewidth]{images/"petrinet - example"}
    \caption{concrete syntax}
    \label{subfig:petriconcrete}    
  \end{subfigure}
  \begin{subfigure}[t]{.35\textwidth}
    \centering
    \includesvg[width=\linewidth]{images/"csd - petrinet-example"}
    \caption{abstract syntax}
    \label{subfig:petriabstract}    
  \end{subfigure}
  \caption{concrete and abstract representation for a simple Petrinet example}
  \label{fig:petrinets_example}
\end{figure} 

\subsection{Statechart Syntax}
\label{sec:statecharts}
as a second example, Statecharts were chosen. The term Statecharts was first coined in 1987 by D. Harel \cite{harel1987statecharts}. Statecharts are an extension of state machines. Their primary feature is that each state can have its own sub state machines. \Cref{fig:statechartmm} describes the abstract syntax metamodel that is used in this thesis. This does not represent a complete specification of the complete Statecharts syntax, rather a sub set which can be used to highlight certain areas of the implementation. Statecharts define a more complex syntax than the aforementioned Petrinets and thus will be used to show the developed artifacts applicability towards more complex modeling languages.

\begin{figure}
\centering
\includesvg[width=.7\linewidth]{images/"csd - new-statechart-metamodel"}
\caption{Abstract Metamodel of Statecharts}
\label{fig:statechartmm}
\end{figure}

At its core Statecharts are composed of \emph{States} and \emph{Transitions}.
Each state can have its own sub state 

Statecharts are primarily composed of StateElements and Transitions. Transitions possess an event. 
StateElements are split into \emph{States} and \emph{PseudoStates}. PseudoStates have one of several kinds, defined by the PseudoStateKind. States are called simple State if they posses no sub state machine. In the case they do encompass a sub state machine they are called compound State. A compound State can have multiple sub states, in this case they can be split apart using a dashed separator line, to create \emph{Regions}. Each Region contains its own state machine.


\begin{figure}
\centering
\includesvg[width=\linewidth]{images/"visualization - statechart-example"}
\caption{Concrete representation of an example Statechart}
\label{fig:statechart-example}
\end{figure}

% \begin{table}[ht]
%   \centering
% \begin{tabular}[width=.1\linewidth]{| Sc | Sc | Sc |}
%   \hline
%   Simple State & Compound State & Compound State w/ Regions
%   \\
%   \hline
%   \includegraphics[width=.2\linewidth]{images/"visualization - simpleState"} 
%   & 
%   \includegraphics[width=.3\linewidth]{images/"visualization - compoundState"} 
%   & 
%   \includegraphics[width=.35\linewidth]{images/"visualization - region-compound-state"}
%   \\
%   \hline
% \end{tabular}
% \caption{Possible representations for states}
% \label{tab:state-states}
% \end{table}
concepts ignored:
\begin{itemize}
  \item entry/ exit actions
  \item event parsing (guards)
\end{itemize}



\section{CouchEdit}
\label{sec:CouchEdit}
As noted in \Cref{sec:problem_statement}, the \textsc{CouchEdit} framework is based on the ideas of Van Tendeloo, et al. \cite{van_tendeloo_concrete_2017}. In their paper, the authors criticize that classic approaches to modeling frontends usually create one monolithic construct, which handles both the graphical model display as well as the corresponding abstract syntax. This creates tight coupling between the two, which causes low flexibility of the UI and high effort requirements, to implement new features. 

They propose to solve this, by defining two metamodels, one describing the graphical syntax and one the abstract syntax. The render syntax metamodel specifies graphic primitives that a given graphical modeling syntax is made of. instances of this metamodel are managed by the frontend and a user can manipulate this concrete representation directly by adding, deleting or modifying Elements in the UI (if the frontend allows changes). On The other side stands the abstract syntax metamodel, it describes the conceptual representation of a modeling syntax. Instances of this metamodel are managed by the backend. To then connect these two metamodels, a further metamodel, called concrete syntax metamodel, can be defined. This concrete syntax metamodel specifies a connection that maps the concrete graphical representation onto an abstract representation (\Cref{fig:transmm}). 

\begin{figure}
  \centering
  \includesvg[width=.7\linewidth]{images/"presentation - transfere-metamodel"}
  \caption{Depiction of \textsc{CouchEdit}'s approach to separating graphical and abstract representation}
  \label{fig:transmm}
  \end{figure}

Following this architecture, \textsc{CouchEdit} separates frontend and abstract syntax model. The frontend at its core is a simple vector drawing application that implements further functionality for diagrams. A Backend then has the responsibility to analyze these vector graphics and map them onto a corresponding abstract syntax representation. For this, the backend utilizes a set of independent components, that each are responsible for detecting different aspects of the diagram. Each Component contains its own state. When a component makes changes to its state, it also publishes these changes so that other components, interested in these changes, can use them to calculated follow up changes.  

This architecture, has the advantage of being very detangled. this allows for components to be improved in isolation from the rest of the system and the clear separation of concerns makes it easier to understand, which component is responsible for what task. Furthermore, components can be swapped out depending on what tasks are needed for the configured modeling syntax.



\subsection{Data Model}
\textsc{CouchEdit} uses a hypergraph of Elements and Relations to represent its data. Each component has its own instance of this graph that only contains the area of the graph, that is interesting to this component. A component can manipulate its personal graph and make these changes known to the system, so that other components can use them as well.


\subsubsection{Elements}
\texttt{Elements} are the base type of \textsc{CouchEdit}'s hypergraph. Every type of node in this graph inherits from the \texttt{Element} type. As all hypergraph instances should be independent from each other, it is not possible to access \texttt{Elements} via their object reference. Thus every \texttt{Element} has an unique id that kann be used to reliably identify it across multiple graphs. \texttt{Elements} also have a \texttt{probability} attribute that denotes how probable it is that this \texttt{Element} is the result of a correct interpretation of the given hypergraph. This \texttt{probability} object can be set to \texttt{Explicit}, which means that, either this \texttt{Element} describes a factual truth or it was marked by the user as not to be changed. Furthermore, \texttt{Element} subtypes can introduce further attributes that contain important information for the given type.

\subsubsection{Relations}
\texttt{Relations} represent edges of the hypergraph. Each \texttt{Relation} connects a set of source \texttt{Elements} to a set of target \texttt{Elements}. They also inherit from the \texttt{Element} type and thus can recursively be connected with relations themselves. The connected vertices are referenced using the \texttt{ElementReference} class. This class holds an \texttt{Elements} unique id as well as its type, which then can be used to find a referenced \texttt{Element} in the hypergraph. \Cref{fig:relations} shows the implementation of \texttt{Relations}. 

\begin{figure}[ht]
  \centering
  \includesvg[width=.8\linewidth]{images/"csd - relation"}
  \caption{Class diagram of Relations}
  \label{fig:relations}
\end{figure}

 While \texttt{Relations} can connect multiple source and target vertices, the most common \texttt{Relation} type is the \texttt{OneToOneRelation}, it describes a connection between exactly one source and one target \texttt{Element}. A common example, for such a \texttt{OneToOneRelation}, is the \texttt{Contains} relations, which defines that one \texttt{Element} encloses another.  


\subsubsection{Graphic Objects}
\emph{Graphic objects} (GOs) represent atomic elements, that the user interacts with via the Frontend. An important decision, when designing an Editor is the question on how granular singular graphic objects should be. On a basic level, GOs can consist of either pixels or vectors. a pixel based Approach would require a visual recognition preprocessor, that composes the state of pixels in to comprehensible graphic primitives. While such form of image recognition is outside the scope of the \textsc{CouchEdit} project, similar projects such as \textsc{FlexiSketch} \cite{wuest_flexisketch_2015} show the application of this approach. On the other hand most modeling approaches with some form of abstract syntax processing, build specialized graphic elements with the purpose of representing a specific element of the abstract syntax. Therefore mapping the concrete syntax to an abstract representation is made easy. But as a result these graphic elements are very strict in their graphical representation.

\textsc{CouchEdit}'s goal is it to allow users to construct diagrams using elementary, "multi-purpose" graphic objects as well as specialized elements (if required by the modeling language) \cite{nachreiner_couchedit_2020}. To this end, \textsc{CouchEdit} uses a render metamodel (RenderMM). It defines all building blocks that are usable in a concrete representation. \textsc{CouchEdit} builds its RenderMM upon the Classification of Costagliola, et al. \cite{costagliola_classification_2002}. This classification defines a graphic element on its lowest level as a primitive graphic shape (e.g circle, line)  Via sub-classing, these primitive GOs can then be extended to form specialized, \emph{complex graphic objects}.

In his work, The “Physics” of Notations: Toward a Scientific Basis for Constructing Visual Notations in Software Engineering \cite{moody_physics_2009}, Moody specifies eight variables that can be applied to a single graphic primitive. These attributes are separated into factors that have direct influence on the relations between GOs: Position (horizontal and vertical), shape, size, orientation. And attributes that only serve as visual hints and influence a single GO at a time: color, brightness, texture. \textsc{CouchEdit} realizes this separation as well. Factors with spatial influence are contained in the direct info of the shape. While purely visual attributes are externalized into \emph{AttributeBags}. An AttributeBag is a separate element that can be attached to GraphicObjects and contains secondary information about the given Object.

\subsubsection{HotSpotDefinitions}
Some Modeling Notations define relevant zones in a graphical notation, which are not directly modeled by a GraphicObject and thus are not directly visible to the user but exist as a result of the graphical composition. For example in \cite{bottoni_suite_2004}, attachment points have been identified as such a relevant zone. An attachment point defines an area around a GraphicObject where a connection line can be "attached". This concept is implemented in a more general form through \emph{HotSpotDefinitions}. A HotSpotDefinition is a relation that, similar to GraphicObjects, has a shape and thus can be a target as well as a source of spatial relations.

\subsubsection*{Compartments}
\label{sec:compartments}
One of the more primary applications of HotSpotDefinitions is in the form of \emph{CompartmentHotSpotDefinitions}. Compartments define logical areas of a 
\comment{todo}


\subsection{Application Structure}
\textsc{CouchEdit} builds around independent components, called \emph{Processors} that can be enabled or disabled as needed in a given use case. To this end, the center piece of \textsc{CouchEdit}'s architecture is the \emph{ModificationBusManager}. Every Processor (including the frontend) can be connected to this bus manager (\Cref{fig:processors}). if one Processor publishes a change of the hypergraph, the ModificationBusManager propagates this change to all Processors connected. Each Processor can specify which Element types it is interested and will only receive updates for Elements that match one of those types. 

To communicate these changes in the system \emph{ModelDiffs} are used. Each Diff represents a adding, change or deletion of an Element from the Hypergraph. This allows Processors to calculate correct graph changes based on the incoming changes, instead of having to reevaluated the complete graph. This was added into system because it was suspected that always reevaluating the complete state would cause a lot of overhead. Especially Processors that have to calculate spatial relations turned out to profit a lot from diff based calculations \cite{nachreiner_couchedit_2020}. But calculating the correct follow up state, based on a set of Diffs turned out to be highly error prone. Thus it was suspected that it could be beneficial to reevaluate the complete graph when processing lighter tasks, such as Abstract syntax processing \cite{nachreiner_couchedit_2020}.

\subsubsection{Core Processors}
\label{sec:core-processors}
\textsc{CouchEdit} implements a set of \texttt{Processors} that are integral to most modeling syntaxes. These so called core \texttt{Processors} currently are: 
\begin{description}
  \item[SpatialAbstractor] This \texttt{Processor} has the responsibility to calculate how \texttt{GOs} are positioned to each other. Possible position \texttt{Relations} include: \texttt{RightOf}, \texttt{BottomOf}, \texttt{Intersect}, etc..
  \item[ConnectionEndDetector] The \texttt{ConnectionEndDetector} finds line \texttt{GOs} that could represent a connection to another \texttt{GO}. it Then adds \texttt{ConnectionEnds} relations from the line to the other \texttt{GO}. Furthermore, the \texttt{ConnectionEnd} relation has the attribute \texttt{isEndConnection} that defines, if this relation origins from the ending point of the line.
  \item[Containment] The \texttt{Containment processor}, checks if one \texttt{GO} is contained by another. Meaning, if one \texttt{GO} completely encompasses another \texttt{GO}, the \texttt{Processor} adds a \texttt{Contains} relation from the surrounding \texttt{GO} to the contained one.
\end{description}

\subsection{Services}
\label{sec:services}
\texttt{Processors} may sometimes require to gather additional information, such as. For example it is often needed to find all \texttt{Elements} that are connected to a given \texttt{Element} by a certain \texttt{Relation} type.
To this End, \textsc{CouchEdit} provides \texttt{Services}. \texttt{Services} are separate objects that provide a set of functions. A \texttt{Service} can be required by multiple different \texttt{Processors} and thus must be effectively stateless.



\subsection{Suggestions}
\comment{todo}
