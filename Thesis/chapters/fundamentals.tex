\chapter{Related Work and Fundamentals}

this chapter lays out a knowledge foundation, required in later sections \comment{(*barf* horribly written)}. First an extensive introduction into the CouchEdit architecture is given, that will be needed later on to understand design decisions. Following that, the syntax of the petri net and statechart modeling languages are introduced, which are used in Chapter \ref{chap:design} to explain concepts of the proposed metamodel. Finally, related work is being explored \comment{(to short)}. 


\section{Methodology}
\comment{also only pasted right now}

As this research strives to develop a new metamodel suitable for the CouchEdit framework, it will be conducted in accordance to the Design Science Research (DSR) approach. According to V. Vaishnavi et al. a design science research process consists of five steps \cite{vaishnavi_design_2004}.

\subsection{Problem Awareness}
The first step of a design science research is the identification of existing problems. As specified in section \ref{sec:problem_statement}, it was identified that the current CouchEdit implementation lacks an user friendly way of adapting it to different modeling syntaxes and that it is unclear how a metamodel for this architecture would look like.

\subsection{Suggestion}
With a clear definition of the problem, objectives can be proposed which have to be achieved in order to solve this problem. The first objective of this research is to develop a metamodel for the CouchEdit architecture. To be more precise, a metamodel is to be designed, that can be used to specify model syntax definitions which map concrete graphical syntaxes to Abstract syntax models and is applicable to CouchEdit's architecture. The second objective is to implement a prototype that provides proof of concept for the applicability of the design metamodel.


\subsection{Development}
The primary goal of a design science research is the development of artifacts.
The first artifact to be developed in this research will be a metamodel, that can be used to define new modeling syntaxes for a relaxed conformance editor and is applicable to CouchEdit's architecture. The second artifact that is to be developed, is a prototypical code generator that can translate the developed metamodel into a CouchEdit implementation which will be able to process the defined modeling syntax.

To this end, the first sub step of the development stage will be to do a comprehensive analysis of CouchEdits architecture. In his work L. Nachreiner describes in detail, which modeling features the framework covers and how they are implemented \cite{nachreiner_couchedit_2020}. For each of these features, a sub metamodel has to be designed that can be used to define the given feature (RQ1). The approaches of \cite{minas_specifying_2001} and \cite{fondement_making_2005} provide a DSL implementation from which concepts for potential metamodels could be derived. If for one of the features, a suitable metamodel cannot be found, it would have to be evaluated if the feature could be simplified or even dropped (R1.1). After designing sub metamodels for all features, they then have to be composed together, which results in a first version of an applicable metamodel. 

in the next sub step, the code generator will be implemented, this is an iterative step. first, an implementation will be developed on the basis of the designed metamodel, this should reveal further requirements imposed by CouchEdits architecture (RQ2). The metamodel then has to be adjusted to account for these requirements, which in turn requires changes of the implementation until no further requirements can be deduced. Because of time constraints it will not be possible to implement all of the metamodel's features, instead the prototype will cover a minimal feature set that still suffices to demonstrate the metamodel's applicability for selected modeling syntaxes.

\subsection{Evaluation}
Now that the desired artifacts are fully developed it has to be evaluated how well they do their designated task. The metamodel as the primary artifact of this research has to be evaluated in terms of its applicability to its designated domain. To this end, the metamodel will be demonstrated on the basis of different modeling syntaxes, this should highlight areas in which the metamodel's design excels, as well as design flaws and limitations (RQ3). If time allows, potential flaws can be addressed by returning back to the development phase and revising the artifacts, otherwise flaws are to be highlighted so that future works can address them.

\subsection{Conclusion}
The conclusion stage marks the end of a DSR and the results are written up. This works written part will be the resulting bachelor's thesis as well as all source code and documentation.


\section{CouchEdit}
\label{sec:CouchEdit}
As noted in section \ref{sec:problem_statement}, the CouchEdit framework is based on the Ideas of Van Tendeloo, et al. \cite{van_tendeloo_concrete_2017}. In their paper, the authors criticize that classic approaches to modeling frontends usually create one monolithic construct, which handles both the graphical model display as well as the corresponding abstract syntax. This creates tight coupling between the two, which causes low flexibility of the UI and requires high effort, if new features are to be implemented. 

They propose to solve this, by defining two metamodels, one describing the graphical syntax and one the abstract syntax. The render syntax metamodel specifies graphic primitives that are needed to compose a given modeling syntax. instances of this metamodel are managed by the frontend and a user can manipulate this concrete syntax directly by adding, deleting or modifying Elements in the UI (if the frontend allows changes). On The other side stands the abstract syntax metamodel, it describes the conceptual representation of a modeling syntax. Instances of this metamodel are managed by the backend. To then connect these two metamodels, a further metamodel, called concrete syntax metamodel, can be defined. This concrete syntax metamodel specifies transformations to translate concrete representation into an abstract model and backwards (Figure \ref{fig:transmm}). 

\begin{figure}
  \centering
  \includegraphics[width=.7\linewidth]{images/"presentation - transfere-metamodel"}
  \caption{Depiction of CouchEdit's approach to separating graphical and abstract representation}
  \label{fig:transmm}
  \end{figure}

Following this architecture, CouchEdit separates frontend from the abstract syntax model. The frontend at its core is a simple vector drawing application, that implements further functionality for diagrams. The backend is then analyzing these vector graphics and translating it into a corresponding abstract syntax. For this, the backend utilizes a set of independent components, that each are responsible for detecting different aspects of the diagram. Each Component contains its own state, when a component detects changes and updates its state, it also publishes these changes so that other components, interested in these changes, can use them.  

This architecture, has the advantage of being very detangled. this allows for components to be improved in isolation from the rest of the system and the clear separation of concerns makes it easier to understand, which component is responsible for what task. Furthermore, components can be swapped out depending on what syntax transformations are needed for the configured modeling syntax.



\subsection{Data Model}
CouchEdit uses a Hypergraph of Elements and Relations to represent its data. Each component has its own instance of this graph that only contains the area of the graph, that is interesting to this component. A component can manipulate its personal graph and make these changes known to the system, so that other components can manipulate their personal graph.


\subsubsection{Elements}
Elements are the base type of CouchEdits hypergraph. Every type of node in this graph inherits from the Element type. As all hypergraph instances should be independent from each other, it is not possible to access Elements via their object reference, thus every Element has an unique id, that kann be used to reliably identify an Element across multiple graphs. Elements also have a probability attribute, that denotes how probable it is that this Element is the result of a correct interpretation of the given Hypergraph. This probability object can be set to Explicit, which means that, either this Element describes a factual truth or it was set by the User. Furthermore, an Element subtypes can introduce further attributes, that contain important information for the given type.

\subsubsection{Relations}
Relations represent Edges of the Hypergraph. Each Relation connects a set of source Elements to a set of target Elements. They also inherit from the Element type and thus can recursively be connected with relations themselves. The connected vertices are referenced using the ElementReference class. This class holds an Elements unique id as well as its type, which then can be used to find a referenced Element in the hypergraph. Figure \ref{fig:relations} shows the implementation of Relations. 

\begin{figure}[ht]
  \centering
  \includegraphics[width=.8\linewidth]{images/"csd - relation"}
  \caption{Class diagram of Relations}
  \label{fig:relations}
\end{figure}

Via subtyping of relations, it is possible to have multiple different relations between the same two elements, that all describe different kinds of connections. While Relations can connect sets of source and target vertices, the most common relation sub type is the OneToOneRelation, it describes a connection between exactly one source and one target Element. 


\subsubsection{Graphic Objects}
graphic objects represent atomic elements, that the user interacts with, via the Frontend. An important decision, when designing an Editor is the question on how granular singular graphic objects should be. 

On a basic level, graphic objects can consists of either pixels or vectors. a pixel based Approach would require a visual recognition preprocessor, that composes the state of pixels in to comprehensible graphic primitives. While such form of image recognition is outside the scope of the CouchEdit project, similar projects such as FlexiSketch \cite{wuest_flexisketch_2015} show the possibilities this approach enables.

Most modeling approaches with some form of abstract syntax processing capabilities, build graphic elements with the purpose of representing a specific element of the abstract syntax. As a result these graphic elements are very strict in their graphical representation. 

CouchEdit Follows the Classification of Costagliola, et al. \cite{costagliola_classification_2002}. This classification defines a graphic element on its lowest level as a primitive graphic shape (e.g circle, line) \comment{(read up if thats actually what costagliola are doing)}. Via sub-classing, a single graphic object can increase in complexity. Such complex graphic object can have  



\begin{itemize}
  \item attribute bag
\end{itemize}


\subsection{Processors}
In CouchEdit the mentioned independent components, are represented as 
subscribe to element types, publish new diffs, connected to bus, model diffs

\subsubsection{Core Processors}
\begin{itemize}
  \item Spatial Abstractor 
  \item ConnectionEnd Processor
\end{itemize}

\subsection{Services}



\begin{itemize}
  \item renderMM - ConcreteMM - AbstractMM
  \item publish/subscribe pattern
  \item attribute bags
  \item model repository
  \item suggestions
\end{itemize}

\section{Modeling Languages}

\comment{\dots}

% \subsection{Graphical Language Theory}
\subsection{Petri Nets Syntax}
In the following, design considerations are explained using a simple petri net syntax. Figure \ref{fig:petrinets_metamodel} shows the abstract syntax metamodel of the used Petri nets syntax. The Petri nets conceptual representation consists of places and transitions. Places also have a token count. each place can have a variable amount of incoming and outgoing transitions, while transitions can have any amount of incoming and outgoing places. 

\begin{figure}[H]
  \centering
  \includegraphics[width=.7\linewidth]{images/"csd - petrinet-metamodel"}
  \caption{Metamodel for a simple petri net abstract syntax}
  \label{fig:petrinets_metamodel}
\end{figure}

The graphic representation of Petri nets is described in table \ref{tab:petri-primitives}. Places are usually represented as circles, while Transitions are depicted as slender rectangles. The number of small black circles inside a place represent this places token count. Furthermore places and transitions possess a label close to their bounding box, that determines their name. Lastly places and transitions have directed connection lines between then. Each connection points from a place or transition towards an element of the opposite type and represents man outgoing connection for the source element and an incoming connection for the target element. A simple concrete instantiation and its corresponding abstract representation is shown in figure \ref{fig:petrinets_example}.

\begin{table}[ht]
  \centering
\begin{tabular}[width=.1\linewidth]{| Sc | Sc | Sc | Sc | Sc |}
  \hline
  Place & Transition & Token & Label & Connection 
  \\
  \hline
  \includegraphics[width=.1\linewidth]{images/"petrinet - place"} 
  & 
  \includegraphics[width=.1\linewidth]{images/"petrinet - transition"} 
  & 
  \includegraphics[width=.1\linewidth]{images/"petrinet - token"}
  & 
  \includegraphics[width=.1\linewidth]{images/"petrinet - label"}
  & 
  \includegraphics[width=.1\linewidth]{images/"petrinet - connection"} 
  \\
  \hline
\end{tabular}
\caption{graphic primitives used to describe petri nets}
\label{tab:petri-primitives}
\end{table}

\begin{figure}[ht!]
  \centering
  \begin{subfigure}[t]{.4\textwidth}
    \centering
    \includegraphics[width=.9\linewidth]{images/"petrinet - example"}
    \caption{concrete syntax}
    \label{subfig:petriconcrete}    
  \end{subfigure}
  \begin{subfigure}[t]{.45\textwidth}
    \centering
    \includegraphics[width=\linewidth]{images/"csd - petrinet-example"}
    \caption{abstract syntax}
    \label{subfig:petriabstract}    
  \end{subfigure}
  \caption{concrete and abstract representation for a simple Petri net example}
  \label{fig:petrinets_example}
\end{figure} 

\subsection{Statechart Syntax}


\begin{figure}
\centering
\includegraphics[width=.7\linewidth]{images/"csd - new-statechart-metamodel"}
\caption{Abstract Metamodel of Statecharts}
\label{fig:statechartmm}
\end{figure}





\comment{...}