\chapter{Evaluation}
\label{chap:evaluation}
One of the most important parts of a Design Science Research process is the evaluation. The developed artifact has to be analyzed and it has to be established, how well the defined goals are realized by the artifact.

The main criteria that has to be evaluated, is the applicability of the developed artifact. Meaning, it has to be analyzed how well the developed artifact satisfies the defined goal. To this end it seems worthwhile to evaluate the prototypes performance as well as its developer usability. 

\section{Performance}
To provide performance optimization possibilities, CouchEdit was developed with the \texttt{Diff} system in mind. \texttt{Diffs} provide the possibility to calculate changes, without the need for reevaluating the complete hypergraph. On the flipside, this means that all possible states of the graph have to be minded. Using this \texttt{Diff} based approach was evaluated as laborious and error prone, but proved invaluable to improve performance of certain processing tasks \cite{nachreiner_couchedit_2020}. Nachreiner's test results showed that especially language specific processing tasks only took up a small amount of the complete processing time. On basis of this result it was decided, that the developed artifact, primarily concerned with language processing, can produce components that reevaluate the complete graph on every change. Plugin processors, such as the \texttt{LabelProcessor} that is expected to cause high load, are still implemented on application level and thus can make use of the performance benefits granted by the \texttt{Diff} system. 

The actual performance overhead, introduced by this artifact could not be analyzed because of time constraints. Thus, future work would have to evaluate this factor. Furthermore it could be explored if \texttt{Processors}, utilizing the \texttt{Diff} based approach, can be generated from the metamodel, therefore reintroducing the performance benefits. In the current architecture, a \texttt{DM Processors} is triggered every time a change is published, so it can reevaluate the graph. Therefore, a single change done in the frontend will often cause each \texttt{DM Processor} to trigger several times. The metamodel introduces a more structured ordering of \texttt{Processors}. This could be used to split up \texttt{Processors} into sub groups. This way \texttt{Processors} in the same group will calculate changes until no \texttt{Processor} can produce new changes. All changes calculated are then bundled and passed to the next group. This could reduce the number of times a language specific \texttt{Processor}, which reevaluates the complete graph, is triggered.  

\begin{figure}
\centering
\includegraphics[width=\linewidth]{images/"component - sub-groups"}
\caption{\texttt{Processors} split into subgroups, where one group is only activated if the previous group has finished processing.}
\label{fig:sub-groups}
\end{figure}

\section{Usability}
Developer usability ask the question on how easy it is to use a tool. The main focus of this research was to develop an artifact that simplifies the process of implementing new modeling syntax configurations for CouchEdit. To this end, it has to be evaluated how well the developed artifact achieves this goal. To find a comprehensive answer to this question, a user study is required. Given the state of the developed artifact as well as the time required to conduct a survey, this goes far beyond the projects scope. Therefore, alternative metrics have to be dissected, in order to determine an inclination regarding this question. 

One metric to highlight is conciseness. As an abstraction of the CouchEdit architecture, the developed artifact should be able to implement similar concepts in less lines of code. The example implementations reflect this. The Petrinets implementation is \petriConfigLoC lines long and produces \petriGeneratedLoC lines of code. Equally, the Statecharts implementation consists of \stateConfigLoC and generates \stateGeneratedLoC lines. In both examples, this means, on average of over 6 lines of source code are generated per line of the configuration. Of course, the code generator most likely generates code that is more verbose than an equivalent written by a developer. therefore this metric is flawed and only serves as a suggestion for the possible usability. 

To further reinforce claims of conciseness, the Statecharts example (\ref{sec:state-impl}) was modeled as closely as possible after the Statecharts configuration implemented in \cite{nachreiner_couchedit_2020}. An exact replica of the modeling syntax implemented by Nachreiner is not possible. The abstract syntax metamodel defined by them, utilizes \texttt{Relations}, which the AbstractMM defined in \ref{sec:abstract-syntax} does not support. This results from the close orientation towards Ecore. Furthermore, the \texttt{ConcreteMM} is opinionated in its approach to define configurations and thus, can naturally not provide the same flexibility as an application level implementation has. Nonetheless, the application level implementation is 1900 lines long \cite{nachreiner_couchedit_2020}, and was realized here in \stateConfigLoC lines. This is primarily contributed to the fact that implementations using the metamodel do not have to mind every possible state of the graph, as well as the reduction of a lot of boilerplate code.

While the artifact abstracts away from the implementation details of \texttt{Processors}, the developer still requires certain knowledge about the framework. Most prominently a developer has to understand the hypergraph. Constraints and rules usually require querying of the hypergraph, therefore it is inevitable to know the existing element types as well as possible Relations and their meaning. Furthermore, it has to be understood which changes, different plugins apply to the graph, as well as what functions are available. Nonetheless, the amount of knowledge required, is still reduced.   

\subsection{plugins}
The plugin system proved as a worthwhile addition to the architecture. The example language configurations, described in Section \ref{sec:example-configs} show of how complex tasks can be trivialized if the correct plugin is provided. With the plugin system, new \texttt{Processors} can be added to the library of existing processors, should problems arise that are difficult to solve within the generalized metamodel architecture. Plugins are developed on the application level an thus have access to CouchEdit's complete architecture. On the other hand, this means that developing plugins requires knowledge over the complete CouchEdit framework, which the developed artifact is trying to abstract. Therefore plugins should be implemented as general as possible, so that they can be reused as much as possible. Therein lies the challenge of the plugin system. The usefulness of a plugin depends on how well it can be adapted to different modeling syntaxes. This means that plugins have to be developed with great care. In the example Statecharts implementation (Section \ref{sec:state-impl}), the \texttt{LabelProcessor} prototype failed to solve all labeling requirements imposed by the syntax. This demonstrates the volatility of hastily developed plugin. On the other hand, the ConnectionPlugin, thanks to its simplicity was able to provide a concise solution for the given problem.

\section{Discussion of DisplayClasses}
\comment{kurz ein paar conciderations, zu den vor und nachteilen der DisplayClasses (die ich nicht verwendet hab)}
 



\section{\comment{Something Something TGG Discussion}}
\comment{Ich sollte wohl irgendwas dazu schreiben, warum ich keinen klassischen TGG approach gewählt hab, aber ich weiß nicht was} 


% \begin{itemize}
%   \item suggestions
%   \item syntactic correctness
%   \item plugin processor needed for specialized tasks
%   \item plugins need to to be well designed (to specialized\\
%         and is general applicability drops,badly designed config model and its a hassle to use )
% \end{itemize}

