\chapter{Evaluation}
\label{ch:evaluation}
One of the essential parts of a Design Science Research process is the evaluation. The developed artifact has to be analyzed, and it has to be established, how well the artifact realizes the defined goals.

The main criteria that have to be evaluated is the applicability of the developed artifact. Meaning, it has to be analyzed how well the developed artifact satisfies the defined goal. To this end, it seems worthwhile to evaluate the prototype's performance as well as its developer usability.

\section{Performance}
\label{sec:performance}
To provide performance optimization possibilities, \textsc{CouchEdit} was developed with the \emph{Diff} system in mind. Diffs provide the possibility to calculate changes, without the need for reevaluating the complete hypergraph. On the flip side, this means that all possible states of the graph have to be minded. Using this Diff based approach was evaluated as laborious and error-prone, but proved invaluable to improve the performance of specific processing tasks \cite{nachreiner_couchedit_2020}. Nachreiner's test results showed that especially language specific-processing tasks only took up a small amount of total processing time. Based on this result, it was decided that the developed artifact, primarily concerned with language processing, can produce components that reevaluate the complete graph on every change. Plugin processors, such as the LabelProcessor that is expected to cause high load, are still implemented on application level and can use the performance benefits granted by the Diff system.

While this research does not aim to produce detailed performance results, it was nonetheless attempted to provide a simple indication of the artifact's impact on performance. To this end, the \texttt{StateGridTest} defined in \cite{nachreiner_couchedit_2020} (\Cref{app:testsetup}) was adapted to work with the code generated by the Statecharts implementation (\Cref{sec:state-impl}). The StateGridTest was then run 50 times for both the reference implementation of \cite{nachreiner_couchedit_2020} and the implementation of \Cref{sec:state-impl}. The tests were carried out on a modern system containing an Intel Xeon E2-1231 v3 CPU with 3.40GHz clock and 16GB DDR3 RAM with 1600MHz clock. The system was running Windows 10 version 2004. The results of this test suit are depicted in \Cref{fig:performance}. It becomes immediately apparent that the generated code performs worse than the reference implementation. Especially with higher counts of GraphicObjects, the generated implementation needs exponentially more time than the reference values. During test runs, it became clear that the generated implementation starts to max out CPU capacity very early on. Thus the rapid growth in processing time can be attributed to hardware bottlenecks. 

\begin{figure}
  \centering
  \begin{tikzpicture}
    \begin{axis}[
        width=.8\linewidth,
        height=7cm,
        ylabel={Processing time in ms},
        xlabel={Number of States},
        xtick={1,2,3,4,5,6,7,8,9,10,11},
        xticklabels={9,16,25,36,49,64,81,100,121,144,169}
      ]
      \addplot table [x=a, y=b, col sep=comma] {generatedimpl.csv};
      \addlegendentry{generated}
      \addplot table [x=a, y=b, col sep=comma] {nativeimpl.csv};
      \addlegendentry{native}
    \end{axis}
  \end{tikzpicture}
  \caption{Performance comparison between reference implementation and generated implementation in the StateGridTest}
  \label{fig:performance}
\end{figure}

While it is not clear which part of the implementation is responsible for causing this much CPU load, there are still multiple points that could contribute. First and foremost, reevaluating the complete hypergraph in the current implementation is probably the most significant contributor to processing time. In the undirected architecture of \textsc{CouchEdit}, publishing a single change to the hypergraph means that every processor interested in this change will be triggered. The current implementation of the code generator cannot prune the elements a processor is interested in.  This would require an analysis of constraints and rules, which requires a complete metamodel definition of this part. Therefore every change published triggers all processors no matter if a processor is interested in the type of change. This, combined with the fact that each generated processor reevaluates the complete state, causes much overhead. Future implementations could amend this problem by introducing the constraint and rule analysis mentioned above and using it to prune each processor's hypergraph. Furthermore, it could be possible to reintroduce the Diff based architecture into generated processors. This requires that it is possible to determine which parts of the hypergraph are actually affected by a given Diff. Lastly, the developed metamodel introduces a more structured ordering of processors. This could be used to split up processors into subgroups. This way processors, in the same group will calculate changes until no processor can produce new changes. All changes calculated are then bundled and passed to the next group. This could reduce the number of times a generated processor is triggered and has to reevaluate the state.

\begin{figure}
  \centering
  \includesvg[width=.8\linewidth]{images/"component - sub-groups"}
  \caption{Processors split into subgroups, where one group is only activated if the previous group has finished processing.}
  \label{fig:sub-groups}
\end{figure}

\section{Usability}
Developer usability asks the question of how easy it is to use a tool. This research's main focus was to develop an artifact that simplifies the process of implementing new modeling syntax configurations for \textsc{CouchEdit}. To this end, it has to be evaluated how well the developed artifact achieves this goal. A user study would be required to find a comprehensive answer to this question. Given the state of the developed artifact and the time required to conduct a survey, this goes far beyond this project's scope. Therefore, alternative metrics have to be dissected in order to determine an inclination regarding this question.

One metric to highlight is conciseness. As an abstraction of the \textsc{CouchEdit} architecture, the developed artifact should allow implementing similar concepts in fewer lines of code. The example implementations reflect this. The Petri nets implementation is \petriConfigLoC lines long and produces \petriGeneratedLoC lines of code. Equally, the Statecharts implementation consists of \stateConfigLoC and generates \stateGeneratedLoC lines. In both examples, on average, over six lines of source code are generated per line of the configuration. Of course, the code generator most likely generates a more verbose code than an equivalent written by a developer. Therefore, this metric is flawed and only serves as a suggestion towards the artifact's usability.

To further reinforce conciseness claims, the Statecharts example (\Cref{sec:state-impl}) was modeled as closely as possible after the Statecharts configuration implemented in \cite{nachreiner_couchedit_2020}. An exact replica of the modeling syntax implemented by Nachreiner is not possible. The abstract syntax metamodel defined by them, utilizes Relations, which the AbstractMM defined in \Cref{sec:abstract-syntax} does not support. Furthermore, the ConcreteMM abstracts away from implementation details and can naturally not provide the same flexibility as an application-level implementation has.  Nonetheless, the application-level implementation is 1900 lines long \cite{nachreiner_couchedit_2020}, and was realized here in \stateConfigLoC lines. This primarily contributes to the fact that implementations using the metamodel do not have to mind every possible state of the graph and reduce boilerplate code.

While the artifact abstracts away from a processors' implementation details, the developer still requires knowledge about the framework. Most prominently, a developer has to understand the hypergraph. Constraints and rules usually require querying of the hypergraph. Therefore it is inevitable to know the existing element types as well as possible Relations and their meaning. Furthermore, it has to be understood, which changes different plugins apply to the graph, as well as what functions are available. Nonetheless, the amount of knowledge required is still reduced.

\subsection{Plugins}
The plugin system proved as a worthwhile addition to the architecture. The example language configurations described in \Cref{sec:example-configs} showed how complex tasks could be trivialized if the correct plugin is provided. With the plugin system, new Processors can be added to the library of existing processors, should problems arise that are difficult to solve within the generalized metamodel architecture. Plugins are developed on the application level and thus have access to \textsc{CouchEdit}'s complete feature set. On the other hand, developing plugins requires knowledge over the complete \textsc{CouchEdit} framework, which the developed artifact is trying to away from abstract. Therefore plugins should be implemented as general as possible to be reusable as much as possible. Therein lies the challenge of the plugin system. The usefulness of a plugin depends on how well it can be adapted to different modeling syntaxes. This means that plugins have to be developed with great care. In the example Statecharts implementation (\Cref{sec:state-impl}), the LabelProcessor prototype failed to solve all labeling requirements imposed by the syntax. This demonstrates the applicability of hastily developed plugins. On the other hand, the ConnectionPlugin, thanks to its simplicity, provided a straightforward solution for the given problem.

\section{Discussion of DisplayClasses}
\label{sec:dc-disc}
During the initial evaluation of the architecture proposed by Fondement and Baar \cite{fondement_making_2005}, it was decided not to adopt the concept of DisplayClasses, proposed by the Authors. This decision was made because their implementation details were not sure. It was estimated that DisplayClasses would introduce further complexity without providing any significant advantages. Concerning the developed artifact, this turned out as mostly true. Nonetheless, there are scenarios and considerations towards future work that could make an implementation utilizing DisplayClasses relevant.

When tightening requirements towards the concrete syntax, DisplayClasses could prove useful. For example, if it is required that a Place in the Petri nets syntax always has a name, the same part of the graph has to be queried two times. First, the PlacePatternProcessor would have to check if a label is assigned to a Place before adding the Pattern element of type Place. Then the PlaceRecognitionProcessor can add the PlaceDM. Afterwards, the PlaceSyncProcessor has to query the same part of the Graph that the PlacePatternProcessor already queried, to find the corresponding label. This double querying could be prevented, using DisplayClasses, as the PlaceSyncProcessor could get the Label connected to the DisplayClass already, similar to the invariant shown in \Cref{lst:ocl-inv}.

Another scenario that could make DisplayClasses relevant is concerned with syntax feedback in the frontend. \textsc{DiaGen} marks graphical elements that are part of a syntactic correct concrete representation \cite{minas_concepts_2002}. Such a feature could be conceivable in future iterations of frontends for \textsc{CouchEdit}. With the pattern system developed in this thesis, there is no direct connection between all GOs and the abstract representation they are part of. Using DisplayClasses, every GO has a direct connection to the abstract representation they are mapped to. Thus, DisplayClasses would trivialize the implementation of a feature similar to \textsc{DiaGen}'s.


% \begin{itemize}
%   \item suggestions
%   \item syntactic correctness
%   \item plugin processor needed for specialized tasks
%   \item plugins need to to be well designed (to specialized\\
%         and is general applicability drops,badly designed config model and its a hassle to use )
% \end{itemize}

