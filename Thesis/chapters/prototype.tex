\chapter{Prototype}
\label{ch:prototype}
Alongside the development of the metamodel, described in \Cref{ch:design}, a prototype was developed, which serves as proof of concept for design decisions. This prototype is realized as an extension of \textsc{CouchEdit}'s current existing prototype, developed by Nachreiner and presented in \cite{nachreiner_couchedit_2020}.

\textsc{CouchEdit}'s current running prototype is wholly written in Kotlin\footnote{\url{https://kotlinlang.org/}}, a programming language with the ability to compile to the Java virtual machine platform. Thus, Kotlin enables access to Java's ecosystem of libraries and frameworks. TornadoFX\footnote{\url{https://tornadofx.io/}}, a JavaFX wrapper, is used as the UI Framework. As a modeling tool, GEF\footnote{\url{https://www.eclipse.org/gef/}} was integrated. Dependencies are handled using the dependency injection framework Guice\footnote{\url{https://github.com/google/guice}}, which integrates perfectly with \textsc{CouchEdit}'s modular architecture. Detailed information about the current prototype and its features are presented in \cite{nachreiner_couchedit_2020}.

In theory, integrating \textsc{CouchEdit} with a parser that can evaluate language configurations at runtime would be preferable. This would make it possible to hot-swap configurations while the software is running. Instead, the prototype was extended by a code generator. This has multiple reasons. The current implementation is relying on the existence of class definitions. Meaning, at many points in the code, object types are checked. A runtime parser would have to either create workarounds for these type checks or compile the needed classes at runtime, using byte code manipulation. A code generator can generate all class definitions directly and thus solves this problem without any extra effort. 

Furthermore, a code generator can work with a metamodel that is not fully defined. As noted in \Cref{ch:design}, low-level language concepts were not fully defined, as they depend on the actual language implementation. Therefore, the implemented parser accepts strings at places where the metamodel is not entirely defined. Statements and expressions can simply be written directly into these strings, which are then placed into the generated code without further analysis of their correctness. This means that these strings have to contain Kotlin code. Furthermore, needed language concepts (\Cref{sec:language-concepts}) have to be provided by the Kotlin implementation itself.

The code generator was implemented as a separate sub-module of the existing prototype. It contains its own application entry point that, when executed, will generate a new module. This module provides the language configuration, which is loaded by the model application when started, and automatically configures the application for this modeling syntax. For code generation purposes, FreeMarker\footnote{\url{https://freemarker.apache.org/}} is used. FreeMarker is a language-agnostic template engine and therefore allows for the generation of Kotlin code out of the box.

It was also decided to implement an internal DSL, using Kotlin's integrated capabilities\footnote{\url{https://kotlinlang.org/docs/reference/type-safe-builders.html}}. While not as versatile as external DSLs, Kotlin's capabilities are sufficient to define lightweight DSLs. They are defined directly in Kotlin source code and thus do not require any extra DSL parsers. Therefore, they are easy to implement while still providing a suitable syntax for defining instances of the developed configuration metamodel.

\section{Kotlin DSL}
The \textsc{CouchEdit} DSL comprises three distinct parts, each representing one of the sub metamodels defined by the \textsc{CouchEdit} configuration. Each \textsc{CouchEdit} configuration consists of three files, \texttt{RenderMM}, \texttt{ConcreteMM}, and \texttt{AbstractMM}, describing each of the three sub-metamodels the \textsc{CouchEdit} configuration encompasses.

\subsection{Render DSL}
Given the simplicity of the RenderMetamodel defined in this work, the corresponding DSL does not encompass much grammar. The \texttt{RenderMM} DSL provides a set of constants, each representing a shape supported by the framework. A configuration takes a set of these constants. Future work would have to look at how graphical attributes work with the system and the integration of complex graphic objects. An example of such a \texttt{RenderMM} instance for a Petri nets configuration is shown in \Cref{lst:petri-rendermm}.

\subsection{Abstract DSL}
It was noted in \Cref{sec:abstract-syntax} that the abstract syntax metamodel could be defined using existing tools such as Ecore. As developing a functioning Ecore parser was deemed too complicated, the prototype instead implements a barebones grammar that allows for the definition of a subset of the Ecore metamodel. Notably, the DSL allows for the definition of enums and classes. While interface definitions are worthwhile as well, they are not yet supported.

% \textsc{\textbf{Classes:}} Class definitions are used to define classes 

% \lstinputlisting[captionpos=b,caption={Place \texttt{Class} definition},linerange={6-11}]{code/configs/petrinets/AbstractMM.kts}

% \textsc{\textbf{Enums:}}

% \lstinputlisting[captionpos=b,caption={PseudoStateKind \texttt{Enum} definition},linerange={15-19}]{code/configs/statechartsnew/AbstractMM.kts}

\emph{StructuralFeatures} allow for the definition of attributes a class possesses. Most notably, they allow for the definition of attributes and references to other classes. A StructuralFeature holds a name, and upper and lower bound definitions, where an upper bound of `-1` indicates that it is unbound. Furthermore, a StructuralFeature can hold a default value. The DSL allows for the definition of StructuralFeatures in the form of three symbols, \texttt{attr}, \texttt{ref}, and \texttt{comp}. \texttt{attr} is used to define simple attributes, a class definition can hold. Currently, supported attribute types are: \texttt{boolean}, \texttt{string}, \texttt{integer}, \texttt{double}, and \texttt{object}, as well as any enums defined. \texttt{ref} and \texttt{comp} can be used to define references to other classes. Because of limitations imposed by the Kotlin DSL, enum as well as class reference names have to be wrapped into string literals. While \texttt{ref} defines standard references, \texttt{comp} defines compositions. This plays an important role when generating source code from this configuration. References define connections to objects that can exist by themselves. In the \textsc{CouchEdit} architecture, that means they have to exist in the application's hypergraph. Thus they can only be referenced using ElementReferences (\Cref{sec:relations}). On the other hand, composition objects do not exist as separate entities in the graph and must not be referenced using ElementReferences. The \texttt{AbstractMM} definition for Petri nets is shown in \Cref{lst:petri-abstractmm}.

\subsection{Concrete DSL}
The concrete syntax metamodel definition is the centerpiece of the developed artifact. Thus defining this part was the main focus during the development process. An example definition for a Petri nets \texttt{ConcreteMM} configuration is shown in \Cref{lst:petri-concretemm}. Similarly to the metamodel defined in \Cref{ch:design}, the \texttt{ConcreteMM} DSL comprises three distinct concepts, with an additional possibility of defining helper functions. Each of the concepts is defined in its own scope. 


\textbf{Helpers:} The \texttt{helpers} scope allows for the definition of helper functions. \texttt{helper} definitions take a name, multiple arguments, as well as a body. A function's return value is determined by its body's last statement, as is done in all following statement blocks. Usually, Kotlin can infer the type of this return value by itself. However, in the case a recursive function is implemented, the return type has to be specified as Kotlin will run into recursive type checking problems. Because of the nature of a variable argument count, introduced by \texttt{param} definitions, body and return type have to be specified using Kotlin's named parameter syntax\footnote{\url{https://kotlinlang.org/docs/reference/functions.html\#named-arguments}}. To reduce the overhead of implementing functions, parameters, and the function body, have to be written in string literals. Thus these values can then later be inserted into the generated Kotlin source code. This enables access to the full Kotlin functionality without having to do any extra work. On the flip side, that means an IDE cannot give any syntax checking for code segments encoded into string literals.

\textbf{Plugins:} The \texttt{plugins} scope allows available plugins to be enabled. The plugins scope, similar to the \texttt{RenderMM} DSL, provides a set of constants, each representing an available plugin. Furthermore, plugins that require additional configuration have their own scope, which provides the grammar required to specify a configuration for this plugin.

\textbf{Patterns:} The \texttt{patterns} scope allows for the definition of new pattern types. Each new pattern type is marked by a \texttt{def} block that contains the pattern's name, followed by a new scope. The scope contains all constraints that a GO has to satisfy in order to be marked with this pattern. A constraint is identified by a `+` followed by a string literal. The string literal represents a complete statement block and can contain multiple statements where the last statement represents the return value. These constraint blocks must return a boolean value and, thus, have to always end in a boolean expression. Furthermore, the constraints are completely isolated from each other. This means, casting the GO in one constraint will not affect the following constraints. On the other hand, these constraints are executed in the order they are defined. If one constraint fails, the following constraints will not be checked. This offers the possibility to safely cast a GO in all constraints when a previous constraint has verified the object's type.

\textbf{DisplayManagers:} The \texttt{displayManagers} scope allows for the definition of new DisplayManagers. A \texttt{def} block marks a new DM definition, which contains a string literal specifying the abstract model element and possibly one literal specifying the corresponding pattern. 
% If no pattern name is given, the definition represents an \texttt{AbstractDisplayManager}. 
Rules are defined in the same way as pattern constraints are. A rule's statement block, on the other hand, has no specific return type. Instead, they directly act on a given DisplayManager and manipulate the corresponding model element. Should two different rules manipulate the same attribute, the rule defined last will overwrite changes done by the first one.

\section{Example Configurations}
\label{sec:example-configs}
This section exhibits two implementation examples, based on the model syntaxes presented in \Cref{sec:modeling-languages}.

\subsection{Petri Nets}
\label{sec:petri-impl}
As a first example, a Petri nets configuration was implemented. This configuration follows the model defined in \Cref{sec:petrinets}, while the complete implementation is shown in \Cref{app:petri}. The complete configuration script, composed of \texttt{RenderMM}, \texttt{AbstractMM}, and \texttt{ConcreteMM}, is \petriConfigLoC lines long\footnote{These metrics were counted with the cloc tool: \url{https://github.com/AlDanial/cloc}}. The Kotlin code generated by this configuration encompasses \petriGeneratedLoC lines. 

Shapes configured in the \texttt{RenderMM} (\Cref{lst:petri-rendermm}) are \texttt{circle}, \texttt{rectangle}, \texttt{line}, and \texttt{label}. With the future development of a more sophisticated RenderMetamodel, the circle shape could be defined separately, once as a small black circle and once as a bigger circle without fill color. 

The \texttt{AbstractMM} (\Cref{lst:petri-abstractmm}) definition has two class definitions. The \texttt{Place} class has one attribute name of type \texttt{string}, and another attribute tokens with type \texttt{integer} which has its bound fixed to "1" and a default value "0". Furthermore, the \texttt{Place} class has two references, incoming and outgoing, with the type \texttt{Transition} and an unlimited upper bound, indicated by "-1". The Transition class is defined in the same fashion.

The \texttt{ConcreteMM} (\Cref{lst:petri-concretemm}) definition has the ConnectionPlugin, and LabelPlugin, mentioned in \Cref{sec:plugins} enabled. The ConnectionPlugin, in its current iteration, does not take a configuration. The LabelPlugin, on the other hand, is configured to detect labels that are close to a graphic object with the pattern \texttt{Place} or \texttt{Transition}. If this results in more than one possible LabelFor relation, the result is discarded as noted by "\texttt{ifAmbiguous nothing}". The \texttt{patterns} scope has three patterns defined, \texttt{Place}, \texttt{Token}, and \texttt{Transition}. \texttt{Place} and \texttt{Transition} constraints are defined similarly to the examples given in \Cref{sec:recognition}. However, the \texttt{Transition} pattern contains an additional constraint that checks if a rectangle has one side at least double the other side's length.  The \texttt{Token} pattern is used to detect elements that represent a token to ease the process of syncing the token count. The \texttt{DisplayManagers} scope has two definitions, one \texttt{PlaceDM}, and one \texttt{TransitionDM}. The \texttt{PlaceDM} connects the \texttt{Place} pattern to the \texttt{Place} model element. It has four rules, one for each of its attributes. Similarly, the \texttt{TransitionDM} connects the \texttt{Transition} pattern to the \texttt{Transition} model element and has three rule definitions.

The Petri nets configuration provides an example of how to use the developed prototype to define \textsc{CouchEdit} configurations. 

\subsection{Statecharts}
\label{sec:state-impl}
As a second example, the Statecharts syntax defined in \Cref{sec:statecharts} was realized. However, the configuration does leave out some of the described functionality. This was done to align this implementation closer with the example presented in \cite{nachreiner_couchedit_2020}. Therefore this configuration can then later serve as a point of evaluation. Notably, the implementation of pseudo states was left open. The complete source code of this implementation is listed in \Cref{app:state}. While the Petri nets example was explained in detail to demonstrate the usage of the developed DSL, this section only describes the implementation's noteworthy aspects.

Similarly to the Petri nets implementation presented in the prior section, this configuration has the LabelPlugin and ConnectionPlugin enabled. Furthermore, the \emph{CompartmentDetectorPlugin} is enabled, which enables compartmentalization, as described in \Cref{sec:hotspotdefinitions}.

% This implementation showcases how patterns can be used to split up problems into smaller parts. 

Detecting regions poses some special challenges. It is not only possible to split a state into two regions. It is also possible to further split up one region into two. This means that each CompHSD itself can have two more CompHSDs. Therefore the deepest CompHSDs have to be found as only they represent a region. To solve this problem, the implementation makes use of two different patterns, \texttt{DashedRegion} and \texttt{Region}. The \texttt{DashedRegion} pattern is responsible for detecting if a CompHSD is created through a \emph{dashed} line and is a compartment of a State object. The \texttt{Region} pattern is then responsible for checking if a CompHSD that satisfies the \texttt{DashedRegion} pattern has no further sub-compartments, making it a region of the parent State.

In the initial design, the LabelPlugin was configured to prioritize states over transitions. This was deliberately designed to solve problems, such as shown in \Cref{fig:close-enough}. While a human can easily interpret this concrete representation, it would become problematic for the LabelPlugin to assign the label without a precedence rule correctly. However, this precedence rule turns out to be problematic when handling sub-state machines. With this rule, it becomes impossible to label transitions that are part of a sub-state machine. The State precedence rule will block all transition labeling for sub-states. This makes the rule not applicable to solve the given problem and thus mostly invalidates the usefulness of the LabelPlugin for the given problem. Instead, the LabelPlugin has to be configured to check state and transition labels independently from each other. This means, to solve the problem depicted in \Cref{fig:close-enough}, LabelFor relations have to be checked manually. To this end, the helper \texttt{hasSameParent} is defined. This function checks if two elements are contained by the same parent or no parent at all. If this is true, both elements are part of the same hierarchy. This function is used to check if label and transition are part of the same state machine and could be associated with each other. This provides a functional workaround to solve the given problem. However, the drawback of this is that most of the functionality the LabelPlugin intends to provide cannot be used. Instead, when finding a corresponding label, all LabelFor relations have to be scanned and filtered in the relevant rule definitions, which increases the implementationâ€™s complexity.  

\begin{figure}
\centering
\includesvg[width=.6\linewidth]{images/"visualization - close-enough"}
\caption{Example of problematic labeling without precedence rules.}
\label{fig:close-enough}
\end{figure}

