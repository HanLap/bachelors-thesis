\chapter{Prototype}
Along side the development of the metamodel, described in Chapter \ref{chap:design}, a prototype was developed as well, which serves as a proof of concepts for design decisions made. This prototype is realized as an extensions of CouchEdit's current existing prototype, developed bei Nachreiner and presented in \cite{nachreiner_couchedit_2020}.

CouchEdit's current running prototype is completely written in Kotlin\footnote{\url{https://kotlinlang.org/}}, a programing language with the ability to compile to the Java virtual machine platform. Thus, Kotlin enables access to Java's ecosystem of libraries and Frameworks. TornadoFX\footnote{\url{https://tornadofx.io/}}, a JavaFX wrapper, is used as UI Framework. As a modeling tool, GMF\footnote{\url{https://www.eclipse.org/gmf-tooling/}} was integrated. Dependencies are handled using the Dependency Injection framework Guice\footnote{\url{https://github.com/google/guice}}, which integrates perfectly with CouchEdit's modular architecture. More information about the current prototype and its features can be found in \cite{nachreiner_couchedit_2020}.

In theory, integrating CouchEdit with a parser that can evaluate language configurations at runtime would be preferable. This would make it possible to hot swap configurations while the software is running. Instead, the prototype was extended by a code generator. This has multiple reasons. The current implementation is relying on the existence of class definitions. Meaning, at certain points in the code types of Elements are checked (e.g. \texttt{elem is PlaceDM}). A runtime parser would have to either create workarounds for these type checks or compile the needed classes at runtime, using byte code manipulation. A code generator can generate all class definitions directly and thus solves this problem without any extra effort. Furthermore a code generator can work with a metamodel that is not fully defined. As noted in Chapter \ref{chap:design}, low level languages concepts were not fully defined, as they depend on the actual language implementation. To circumvent the problem of defining an actual language implementation for these low level concepts, the implemented parser opts to simple replace these parts with strings. Statements and expressions, can simply be written directly into these Strings, which are then placed into the generated code, without any further analysis of their correctness. This means, that these strings have to contain Kotlin code. Furthermore, needed language concepts have to be provided by the Kotlin implementation itself.

The Code Generator was implemented as a separate sub module of the existing prototype. It contains its own runnable method that, when executed, will generate a new module. This module contains the language configuration, which is loaded by the model application when started and automatically configured the editor modeling language. For code generation purposes FreeMarker\footnote{\url{https://freemarker.apache.org/}} is used. FreeMarker is a language agnostic template engine, and therefore allows for the generation of kotlin code out of the box. 

To ease the effort of defining language configurations, it was also decided to implement an internal DSL, using Kotlin's integrated capabilities\footnote{\url{https://kotlinlang.org/docs/reference/type-safe-builders.html}}. Furthermore, Kotlin's script API was utilized to allow for configuration files being loaded at runtime. Each CouchEdit configuration consists of three files, \texttt{RenderMM}, \texttt{ConcreteMM} and \texttt{AbstractMM}, describing each of the three sub metamodels, the CouchEdit configuration si composed of. Below the developed DSL is described.

\section{Kotlin DSL}
The CouchEdit DSL is composed of three distinct parts, one for each of the three sub metamodels, defined by the CouchEdit configuration metamodel. 

\subsection{Render DSL}
Given the simplicity of the \texttt{RenderMetamodel} defined in this work, the corresponding DSL does not encompass a lot of grammar. Similar to an enum definition common to most programming languages, the RenderMM 


An example of such a render model definition for a Petri nets configuration, can be seen in Figure \ref{lst:petri-rendermm}

\subsection{Abstract DSL}



\begin{itemize}
  \item Class
  \item enums
  \item default datatypes
\end{itemize}


key methods: 
\begin{itemize}
  \item superType
  \item attr
  \item ref
  \item comp
\end{itemize}

\subsection{Concrete DSL}

\begin{description}
  \item[helper]
  \item[annotations]
  \item[plugins]
  \item[displayManagers]
\end{description}



\section{Example 1: Petri Nets}

\ref{app:petri}

plugins:
\begin{itemize}
  \item connection
  \item label
\end{itemize}

\begin{itemize}
  \item config 148 lines
  \item generated 791 lines
\end{itemize}



\section{Example 2: State Charts}

\ref{app:state}

plugins:
\begin{itemize}
  \item compartmentDetector
  \item label 
\end{itemize}

\begin{itemize}
  \item problematic plugin design
  \item config 196 lines
  \item generated 1331 lines
\end{itemize}
