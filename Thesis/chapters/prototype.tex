\chapter{Prototype}
\label{chap:prototype}
Along side the development of the metamodel, described in Chapter \ref{chap:design}, a prototype was developed as well, which serves as a proof of concepts for design decisions made. This prototype is realized as an extensions of CouchEdit's current existing prototype, developed bei Nachreiner and presented in \cite{nachreiner_couchedit_2020}.

CouchEdit's current running prototype is completely written in Kotlin\footnote{\url{https://kotlinlang.org/}}, a programing language with the ability to compile to the Java virtual machine platform. Thus, Kotlin enables access to Java's ecosystem of libraries and Frameworks. TornadoFX\footnote{\url{https://tornadofx.io/}}, a JavaFX wrapper, is used as UI Framework. As a modeling tool, GEF\footnote{\url{https://www.eclipse.org/gef/}} was integrated. Dependencies are handled using the dependency injection framework Guice\footnote{\url{https://github.com/google/guice}}, which integrates perfectly with CouchEdit's modular architecture. Detailed information about the current prototype and its features are presented in \cite{nachreiner_couchedit_2020}.

In theory, integrating CouchEdit with a parser that can evaluate language configurations at runtime would be preferable. This would make it possible to hot swap configurations while the software is running. Instead, the prototype was extended by a code generator. This has multiple reasons. The current implementation is relying on the existence of class definitions. Meaning, at certain points in the code object types are checked. A runtime parser would have to either create workarounds for these type checks or compile the needed classes at runtime, using byte code manipulation. A code generator can generate all class definitions directly and thus solves this problem without any extra effort. Furthermore a code generator can work with a metamodel that is not fully defined. As noted in Chapter \ref{chap:design}, low level languages concepts were not fully defined, as they depend on the actual language implementation. To circumvent the problem of having to define an actual language implementation for these low level concepts, the implemented parser opts to simply replace these parts with strings. Statements and expressions, can simply be written directly into these Strings, which are then placed into the generated code, without any further analysis of their correctness. This means, that these strings have to contain Kotlin code. Furthermore, needed language concepts (Section \ref{sec:language-concepts}) have to be provided by the Kotlin implementation itself.

The code generator was implemented as a separate sub module of the existing prototype. It contains its own runnable method that, when executed, will generate a new module. This module provides the language configuration, which is loaded by the model application when started and automatically configures the application for this modeling syntax. For code generation purposes FreeMarker\footnote{\url{https://freemarker.apache.org/}} is used. FreeMarker is a language agnostic template engine, and therefore allows for the generation of kotlin code out of the box.

To ease the effort of defining language configurations, it was also decided to implement an internal DSL, using Kotlin's integrated capabilities\footnote{\url{https://kotlinlang.org/docs/reference/type-safe-builders.html}}. Furthermore, Kotlin's script API was utilized, which allows for the relocation of configurations into script files. These files then can be loaded at runtime.

\section{Kotlin DSL}
The CouchEdit DSL is composed of three distinct parts, each representing one of the sub metamodels defined by the \texttt{CouchEditConfiguration}. Each CouchEdit configuration consists of three files, \texttt{RenderMM}, \texttt{ConcreteMM} and \texttt{AbstractMM}, describing each of the three sub metamodels, the CouchEdit configuration is composed of.

\subsection{Render DSL}
Given the simplicity of the \texttt{RenderMetamodel} defined in this work, the corresponding DSL does not encompass much grammar. The RenderMM DSL provides a set of constants, each representing a shape supported by the framework. A configuration takes a set of these constants. Future work would have to look at how graphical attributes work with the system as well as integration of complex graphic objects. An example of such a \texttt{RenderMM} instance for a Petrinets configuration, is shown in Listing \ref{lst:petri-rendermm}.

\subsection{Abstract DSL}
It was noted in Section \ref{sec:abstract-syntax} that the \texttt{AbstractSyntaxMetamodel} can be defined using existing tools such as Ecore. As developing a functioning Ecore parser was deemed to complex, the prototype instead implements a barebones grammar that allows for the definition of a subset of the Ecore metamodel. Notably the DSL allows for the definition of enums and classes. While interface definitions are worthwhile as well, they are not yet supported.

% \textsc{\textbf{Classes:}} Class definitions are used to define classes 

% \lstinputlisting[captionpos=b,caption={Place \texttt{Class} definition},linerange={6-11}]{code/configs/petrinets/AbstractMM.kts}

% \textsc{\textbf{Enums:}}

% \lstinputlisting[captionpos=b,caption={PseudoStateKind \texttt{Enum} definition},linerange={15-19}]{code/configs/statechartsnew/AbstractMM.kts}

\texttt{StructuralFeatures} allow for the definition of attributes a class possesses. Most Notably they allow for the definition of attributes and references to other classes. A \texttt{StructuralFeature} holds a name, as well as upper and lower bound definitions, where an upper bound of `-1` indicates that it is unbound. Furthermore a \texttt{StructuralFeature} can hold a default value. The DSL allows for the definition of \texttt{StructuralFeatures} in form of three symbols, \texttt{attr}, \texttt{ref} and \texttt{comp}. \texttt{attr} is used to define simple attributes, a class definition can hold. Currently supported \texttt{AttributeTypes} are: boolean, string, integer, double, unspecified Java classes and objects, as well as any enums defined. \texttt{ref} and \texttt{comp} can be used to define references to other classes. Because of limitations imposed by the Kotlin DSL, enum as well as class reference names have to be wrapped into string literals. While \texttt{ref} defines standard references, \texttt{comp} defines compositions. This plays an important role When generating source code from this configuration. References define connections to objects, that can exist by themselves. In the CouchEdit architecture that means, they have to exist in the applications hypergraph. Thus they can only be referenced, using \texttt{ElementReferences}. On the other hand, composition objects do not exist as separate entities in the graph und therefore must not be referenced using \texttt{ElementReferences}. the \texttt{AbstractMM} definition for Petrinets is shown in Listing \ref{lst:petri-abstractmm}.

\subsection{Concrete DSL}
The \texttt{ConcreteMM} definition is the centerpiece of the developed artifact, thus defining this part was main focus during the development process. Similarly to the metamodel defined in Chapter \ref{chap:design}, the \texttt{ConcreteMM} DSL is composed of three distinct concepts, with an additional possibility of defining helper functions. Each of the concepts is defined in its own scope.


\textbf{Helpers:} The \texttt{helpers} scope allows for the definition of \texttt{helper} functions. \texttt{helper} definitions take a name, multiple arguments, as well as a body. The functions return value is determined by the bodies last statement, as is done in all following statement blocks. Usually Kotlin can infer the type of this value by itself. In the case a recursive function is implemented, the return type has to be specified as Kotlin will run into recursive type checking problems. Because of the nature of a variable argument count, introduced by \texttt{param} definitions, body and return type have to be specified using Kotlin's named parameter syntax\footnote{\url{https://kotlinlang.org/docs/reference/functions.html\#named-arguments}}. To reduce the overhead of implementing functions, parameters as well as the function body have to be written in string literals. Thus these values can then later be inserted into the generated kotlin source code. This enables access the full Kotlin functionality without having to do any extra work. On the flipside, that means the an IDE can not give any syntax checking for code segments encoded into string literals.

\textbf{Plugins:} The \texttt{plugins} scope allows available plugins to be enabled. Similar to the \texttt{RenderMM} DSL, the plugins scope provides a set of constants, each representing an available plugin. Furthermore, plugins that require additional configuration have their own scope, which provides the grammar required to specify a configuration for this plugin.

\textbf{Patterns:} The \texttt{patterns} scope allows for the definition of new pattern types. Each new pattern type is marked by a \texttt{def} block which contains the patterns name, followed by a new scope. The scope contains all constraints that a \texttt{GO} has to satisfy, to be marked with this pattern. A constraint is by a `+`, followed by a string literal. The string literal represents a complete statement block and thus can contain multiple statements, where the last statement represents the return value. These constraint blocks must return a boolean value und thus, have to always end in a boolean expression. Furthermore the constraints are completely isolated from each other. This means, casting the \texttt{GO} in one constraint will have no effect on following constraints. On the other hand, these constraints are executed in the order they are defined in. If one constraint fails, following constraints will not be checked. this offers the possibility to safely cast a \texttt{GO} in all constraints, when a previous constraint has verified the objects type.

\textbf{DisplayManagers:} The \texttt{displayManagers} scope allows for the definition of new \texttt{DisplayManagers}. Each new manager definition is marked by a \texttt{def} block, that contains a string literal specifying the abstract model element and possibly one literal specifying the corresponding pattern. 
% If no pattern name is given, the definition represents an \texttt{AbstractDisplayManager}. 
Rules are defined in the same way as pattern constraints are. A rules statement block on the other hand has no specific return type. Instead they directly act on a given \texttt{DisplayManager} and manipulate the corresponding model element. Should two different rules manipulate the same attribute, the rule defined last will overwrite changes done by the first one. Rules can be defined in a way as to not change any values of the model element. An Example definition for a Petrinets \texttt{ConcreteMM} configuration is shown in Listing \ref{lst:petri-concretemm}.

\section{Example Configurations}
\label{sec:example-configs}
This section exhibits two implementation examples, based on the model syntaxes presented in Section \ref{sec:modeling-languages}.

\subsection{Petrinets}
\label{sec:petri-impl}
As a first example a Petrinets configuration was implemented. This configuration follows the model defined in Section \ref{sec:petrinets}, while the complete implementation is shown in Appendix \ref{app:petri}. The complete configuration script, composed of \texttt{RenderMM}, \texttt{AbstractMM} and \texttt{ConcreteMM}, is \petriConfigLoC lines long. The Kotlin code generated by this configuration encompasses \petriGeneratedLoC lines. 

Shapes configured in the \texttt{RenderMM} (Listing \ref{lst:petri-rendermm}) are, circle, rectangle, line and label. With future development of a more sophisticated \texttt{RenderMM} configuration, the circle shape could be defined separately, once as a small black circle and once as a bigger circle without fill color. 

The \texttt{AbstractMM} (Listing \ref{lst:petri-abstractmm}) definition has two \texttt{Class} definitions. The \texttt{Place Class} has one attribute \texttt{name} of type string, another attribute \texttt{tokens}, with type integer, a fixed bound to "1" and a default value "0". Furthermore the \texttt{Place Class} has two references, \texttt{incoming} and \texttt{outgoing}, with the type \texttt{Transition} and an unlimited upper bound, indicated by "-1". The \texttt{Transition Class} is defined in the same fashion.

The \texttt{ConcreteMM} (Listing \ref{lst:petri-concretemm}) definition has the connection and label  plugin, mentioned in Section \ref{sec:plugins} enabled. The connection plugin in its current iteration does not take a configuration. The label plugin on the other hand is configured to detect labels that surround a graphic object with the pattern \texttt{Place} or \texttt{Transition}. If this results in more than one possible LabelFor relation, the result is discarded as noted by "\texttt{ifAmbiguous nothing}". One \texttt{helper} was defined, which finds the the text, a place or transition is labeled with. The \texttt{patterns} scope has three patterns defined, \texttt{PLace}, \texttt{Token} and \texttt{Transition}. \texttt{Place} and \texttt{Transition} constraints are defined similar to the examples given in Section \ref{sec:recognition}, but the \texttt{Transition} pattern contains an additional constraint that checks if a rectangle has one side at least double the length of the other side. The \texttt{Token} pattern is used to detect elements that actually represent a token, to ease the process of syncing the token count. The \texttt{DisplayManagers} scope has two definitions, one \texttt{PlaceDM} and one \texttt{TransitionDM}. The \texttt{PlaceDM} connects \texttt{Place} pattern and \texttt{Place} model element.

The Petrinets configuration provides an example on how to use the developed prototype to define CouchEdit configurations. 

% plugins:
% \begin{itemize}
%   \item connection
%   \item label
% \end{itemize}

% \begin{itemize}
%   \item config 128 lines
%   \item generated 787 lines
% \end{itemize}

\subsection{Statecharts}
\label{sec:state-impl}
As a second example, a subset of the Statecharts language was implemented. This implementation realizes the syntax defined in Section \ref{sec:statecharts}. to adhere to the prototype implemented in \cite{nachreiner_couchedit_2020}, pseudo states, as well as event string parsing were not implemented. the complete definition is shown in Appendix \ref{app:state}. The configuration is \stateConfigLoC lines long while the generated source code encompasses \stateGeneratedLoC lines.

This implementation uses connection and label plugins, as well as the \texttt{CompartmentDetector} plugin. The \texttt{CompartmentDetector} adds \texttt{CompartmentHotSpotDefinitions}, a relation that defines sub regions of a \texttt{GO}, if it is split by lines. the Concepts behind Compartmentalization is explained in detail in \cite{nachreiner_couchedit_2020}.

\comment{
\begin{itemize}
  \item shows usefullness of pattern system
  \item Shows weakness of the current label pluginú
\end{itemize}
}
