\chapter{Prototype}
\label{ch:prototype}
Along side the development of the metamodel, described in \Cref{ch:design}, a prototype was developed as well, which serves as a proof of concepts for design decisions made. This prototype is realized as an extensions of \textsc{CouchEdit}'s current existing prototype, developed by Nachreiner and presented in \cite{nachreiner_couchedit_2020}.

\textsc{CouchEdit}'s current running prototype is completely written in Kotlin\footnote{\url{https://kotlinlang.org/}}, a programing language with the ability to compile to the Java virtual machine platform. Thus, Kotlin enables access to Java's ecosystem of libraries and Frameworks. TornadoFX\footnote{\url{https://tornadofx.io/}}, a JavaFX wrapper, is used as UI Framework. As a modeling tool, GEF\footnote{\url{https://www.eclipse.org/gef/}} was integrated. Dependencies are handled using the dependency injection framework Guice\footnote{\url{https://github.com/google/guice}}, which integrates perfectly with \textsc{CouchEdit}'s modular architecture. Detailed information about the current prototype and its features are presented in \cite{nachreiner_couchedit_2020}.

In theory, integrating \textsc{CouchEdit} with a parser that can evaluate language configurations at runtime would be preferable. This would make it possible to hot swap configurations while the software is running. Instead, the prototype was extended by a code generator. This has multiple reasons. The current implementation is relying on the existence of class definitions. Meaning, at certain points in the code object types are checked. A runtime parser would have to either create workarounds for these type checks or compile the needed classes at runtime, using byte code manipulation. A code generator can generate all class definitions directly and thus solves this problem without any extra effort. Furthermore a code generator can work with a metamodel that is not fully defined. As noted in \Cref{ch:design}, low level languages concepts were not fully defined, as they depend on the actual language implementation. To circumvent the problem of having to define an actual language implementation for these low level concepts, the implemented parser opts to simply replace these parts with strings. Statements and expressions, can simply be written directly into these Strings, which are then placed into the generated code, without any further analysis of their correctness. This means, that these strings have to contain Kotlin code. Furthermore, needed language concepts (\Cref{sec:language-concepts}) have to be provided by the Kotlin implementation itself.

The code generator was implemented as a separate sub module of the existing prototype. It contains its own runnable method that, when executed, will generate a new module. This module provides the language configuration, which is loaded by the model application when started and automatically configures the application for this modeling syntax. For code generation purposes FreeMarker\footnote{\url{https://freemarker.apache.org/}} is used. FreeMarker is a language agnostic template engine, and therefore allows for the generation of kotlin code out of the box.

To ease the effort of defining language configurations, it was also decided to implement an internal DSL, using Kotlin's integrated capabilities\footnote{\url{https://kotlinlang.org/docs/reference/type-safe-builders.html}}. Furthermore, Kotlin's script API was utilized, which allows for the relocation of configurations into script files. These files then can be loaded at runtime.

\section{Kotlin DSL}
The \textsc{CouchEdit} DSL is composed of three distinct parts, each representing one of the sub metamodels defined by the \texttt{\textsc{CouchEdit}Configuration}. Each \textsc{CouchEdit} configuration consists of three files, \texttt{RenderMM}, \texttt{ConcreteMM} and \texttt{AbstractMM}, describing each of the three sub metamodels, the \textsc{CouchEdit} configuration is composed of.

\subsection{Render DSL}
Given the simplicity of the \texttt{RenderMetamodel} defined in this work, the corresponding DSL does not encompass much grammar. The RenderMM DSL provides a set of constants, each representing a shape supported by the framework. A configuration takes a set of these constants. Future work would have to look at how graphical attributes work with the system as well as integration of complex graphic objects. An example of such a \texttt{RenderMM} instance for a Petrinets configuration, is shown in \Cref{lst:petri-rendermm}.

\subsection{Abstract DSL}
It was noted in \Cref{sec:abstract-syntax} that the \texttt{AbstractSyntaxMetamodel} can be defined using existing tools such as Ecore. As developing a functioning Ecore parser was deemed to complex, the prototype instead implements a barebones grammar that allows for the definition of a subset of the Ecore metamodel. Notably the DSL allows for the definition of enums and classes. While interface definitions are worthwhile as well, they are not yet supported.

% \textsc{\textbf{Classes:}} Class definitions are used to define classes 

% \lstinputlisting[captionpos=b,caption={Place \texttt{Class} definition},linerange={6-11}]{code/configs/petrinets/AbstractMM.kts}

% \textsc{\textbf{Enums:}}

% \lstinputlisting[captionpos=b,caption={PseudoStateKind \texttt{Enum} definition},linerange={15-19}]{code/configs/statechartsnew/AbstractMM.kts}

\texttt{StructuralFeatures} allow for the definition of attributes a class possesses. Most Notably they allow for the definition of attributes and references to other classes. A \texttt{StructuralFeature} holds a name, as well as upper and lower bound definitions, where an upper bound of `-1` indicates that it is unbound. Furthermore a \texttt{StructuralFeature} can hold a default value. The DSL allows for the definition of \texttt{StructuralFeatures} in form of three symbols, \texttt{attr}, \texttt{ref} and \texttt{comp}. \texttt{attr} is used to define simple attributes, a class definition can hold. Currently supported \texttt{AttributeTypes} are: boolean, string, integer, double, unspecified Java classes and objects, as well as any enums defined. \texttt{ref} and \texttt{comp} can be used to define references to other classes. Because of limitations imposed by the Kotlin DSL, enum as well as class reference names have to be wrapped into string literals. While \texttt{ref} defines standard references, \texttt{comp} defines compositions. This plays an important role When generating source code from this configuration. References define connections to objects, that can exist by themselves. In the \textsc{CouchEdit} architecture that means, they have to exist in the applications hypergraph. Thus they can only be referenced, using \texttt{ElementReferences}. On the other hand, composition objects do not exist as separate entities in the graph und therefore must not be referenced using \texttt{ElementReferences}. the \texttt{AbstractMM} definition for Petrinets is shown in \Cref{lst:petri-abstractmm}.

\subsection{Concrete DSL}
The \texttt{ConcreteMM} definition is the centerpiece of the developed artifact, thus defining this part was main focus during the development process. Similarly to the metamodel defined in \Cref{ch:design}, the \texttt{ConcreteMM} DSL is composed of three distinct concepts, with an additional possibility of defining helper functions. Each of the concepts is defined in its own scope.


\textbf{Helpers:} The \texttt{helpers} scope allows for the definition of \texttt{helper} functions. \texttt{helper} definitions take a name, multiple arguments, as well as a body. The functions return value is determined by the bodies last statement, as is done in all following statement blocks. Usually Kotlin can infer the type of this value by itself. In the case a recursive function is implemented, the return type has to be specified as Kotlin will run into recursive type checking problems. Because of the nature of a variable argument count, introduced by \texttt{param} definitions, body and return type have to be specified using Kotlin's named parameter syntax\footnote{\url{https://kotlinlang.org/docs/reference/functions.html\#named-arguments}}. To reduce the overhead of implementing functions, parameters as well as the function body have to be written in string literals. Thus these values can then later be inserted into the generated kotlin source code. This enables access the full Kotlin functionality without having to do any extra work. On the flipside, that means the an IDE can not give any syntax checking for code segments encoded into string literals.

\textbf{Plugins:} The \texttt{plugins} scope allows available plugins to be enabled. Similar to the \texttt{RenderMM} DSL, the plugins scope provides a set of constants, each representing an available plugin. Furthermore, plugins that require additional configuration have their own scope, which provides the grammar required to specify a configuration for this plugin.

\textbf{Patterns:} The \texttt{patterns} scope allows for the definition of new pattern types. Each new pattern type is marked by a \texttt{def} block which contains the patterns name, followed by a new scope. The scope contains all constraints that a \texttt{GO} has to satisfy, to be marked with this pattern. A constraint is by a `+`, followed by a string literal. The string literal represents a complete statement block and thus can contain multiple statements, where the last statement represents the return value. These constraint blocks must return a boolean value und thus, have to always end in a boolean expression. Furthermore the constraints are completely isolated from each other. This means, casting the \texttt{GO} in one constraint will have no effect on following constraints. On the other hand, these constraints are executed in the order they are defined in. If one constraint fails, following constraints will not be checked. this offers the possibility to safely cast a \texttt{GO} in all constraints, when a previous constraint has verified the objects type.

\textbf{DisplayManagers:} The \texttt{displayManagers} scope allows for the definition of new \texttt{DisplayManagers}. Each new manager definition is marked by a \texttt{def} block, that contains a string literal specifying the abstract model element and possibly one literal specifying the corresponding pattern. 
% If no pattern name is given, the definition represents an \texttt{AbstractDisplayManager}. 
Rules are defined in the same way as pattern constraints are. A rules statement block on the other hand has no specific return type. Instead they directly act on a given \texttt{DisplayManager} and manipulate the corresponding model element. Should two different rules manipulate the same attribute, the rule defined last will overwrite changes done by the first one. Rules can be defined in a way as to not change any values of the model element. An Example definition for a Petrinets \texttt{ConcreteMM} configuration is shown in \Cref{lst:petri-concretemm}.

\section{Example Configurations}
\label{sec:example-configs}
This section exhibits two implementation examples, based on the model syntaxes presented in \Cref{sec:modeling-languages}.

\subsection{Petrinets}
\label{sec:petri-impl}
As a first example a Petrinets configuration was implemented. This configuration follows the model defined in \Cref{sec:petrinets}, while the complete implementation is shown in \Cref{app:petri}. The complete configuration script, composed of RenderMM, AbstractMM and ConcreteMM, is \petriConfigLoC lines long\footnote{These metrics were counted with the cloc tool: \url{https://github.com/AlDanial/cloc}}. The Kotlin code generated by this configuration encompasses \petriGeneratedLoC lines. 

Shapes configured in the RenderMM (\Cref{lst:petri-rendermm}) are, circle, rectangle, line and label. With future development of a more sophisticated RenderMM configuration, the circle shape could be defined separately, once as a small black circle and once as a bigger circle without fill color. 

The AbstractMM (\Cref{lst:petri-abstractmm}) definition has two Class definitions. The Place Class has one attribute name of type string, another attribute tokens, with type integer, a fixed bound to "1" and a default value "0". Furthermore the Place Class has two references, incoming and outgoing, with the type Transition and an unlimited upper bound, indicated by "-1". The Transition Class is defined in the same fashion.

The ConcreteMM (\Cref{lst:petri-concretemm}) definition has the connection and label  plugin, mentioned in \Cref{sec:plugins} enabled. The connection plugin in its current iteration does not take a configuration. The label plugin on the other hand is configured to detect labels that surround a graphic object with the pattern Place or Transition. If this results in more than one possible LabelFor relation, the result is discarded as noted by "\texttt{ifAmbiguous nothing}". One \texttt{helper} was defined, which finds the text, a place or transition is labeled with. The \texttt{patterns} scope has three patterns defined, \texttt{PLace}, \texttt{Token} and \texttt{Transition}. \texttt{Place} and \texttt{Transition} constraints are defined similar to the examples given in \Cref{sec:recognition}, but the \texttt{Transition} pattern contains an additional constraint that checks if a rectangle has one side at least double the length of the other side. The \texttt{Token} pattern is used to detect elements that actually represent a token, to ease the process of syncing the token count. The \texttt{DisplayManagers} scope has two definitions, one \texttt{PlaceDM} and one \texttt{TransitionDM}. The \texttt{PlaceDM} connects \texttt{Place} pattern and \texttt{Place} model element.

The Petrinets configuration provides an example on how to use the developed prototype to define \textsc{CouchEdit} configurations. 

\subsection{Statecharts}
\label{sec:state-impl}
as a second example, the Statecharts syntax defined in \Cref{sec:statecharts} was realized. But the configuration does leave out some of the described functionality. This was done to align this implementation closer with the example presented in \cite{nachreiner_couchedit_2020}. therefore this configuration can then later serve as a point of evaluation. Notably, the implementation of PseudoStates was left open. The complete source code of this implementation is listed in \Cref{app:state}. While the Petrinets example was explained in detail to demonstrate the usage of the developed DSL, this section only describes noteworthy aspects of the implementation.

Similar to the Petrinets implementation presented in the prior section, this configuration has the LabelPlugin and ConnectionPlugin enabled. Furthermore the \emph{CompartmentDetectorPlugin} is enabled which enables compartmentalization as described in \Cref{sec:hotspotdefinitions}.

This implementation showcases how patterns can be used to split up problems into smaller parts. A State can have any amount of Regions to solve this the CompartmentDetectorPlugin is employed which recognizes if an area is split up into multiple parts. It is not only possible to split a State into two regions, it is also possible to further split up one Region into two. This means that a CompartmentHotSpotDefinition itself can have two more CompartmentHotSpotDefinitions. Therefore it is important to find the deepest CompartmentHSDs as only they represent a Region. To solve this problem the implementation makes use of two different patterns, \texttt{DashedRegion} and \texttt{Region}. The \texttt{DashedRegion} pattern is responsible for detecting if a CompartmentHSD is created through a \emph{dashed} line and is a compartment of a State object. The \texttt{Region} pattern is then responsible for checking if a CompartmentHSD that satisfies the \texttt{DashedRegion} pattern has no further sub compartments, making it a Region of the parent State.

In the initial design labeling plugin was configured to prioritize States over Transitions for labeling. This was deliberately designed to solve problems such as shown in \Cref{fig:close-enough}. While this concrete representation can easily be interpreted by a human, without the a precedence rule, it would become problematic for the LabelPlugin to correctly assign the label. But this precedence rule turns out to be problematic when handling sub state machines. With this rule it becomes impossible to label Transitions that are part of a sub state machine. The State precedence rule will block all transition labeling for sub states. This makes the rule not applicable to solve the given problem and thus mostly invalidates the usefulness of the LabelPlugin for the given problem. Instead the LabelPlugin has to be configured so that it checks State and Transition labels independently from each other. This means to solve the problem depicted in \Cref{fig:close-enough} LabelFor relations have to be checked manually. To this end the helper  \texttt{hasSameParent} is defined. This function check if two elements are contained by the same parent or no parent at all. if this is true, both elements are part of the same hierarchy. This function is used to check if label and Transition are part of the same state machine and thus could be associated to each other. This provides a functional workaround to solve the given problem. But the drawback of this is that most of the functionality the LabelPlugin intends to provide cannot be used. Instead, when finding a corresponding label, all LabelFor relations have to be scanned and filtered in the SyncProcessors increases complexity of the implementation.  

\begin{figure}
\centering
\includesvg[width=.6\linewidth]{images/"visualization - close-enough"}
\caption{Example of problematic labeling without precedence rules.}
\label{fig:close-enough}
\end{figure}

