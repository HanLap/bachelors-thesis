\chapter{Design Concept}
% \raggedbottom
\label{ch:design}
In \Cref{sec:CouchEdit} it was established that \textsc{CouchEdit} is composed of three distinct metamodels as depicted in \Cref{fig:transmm}. Thus is seems apparent that the proposed concept should also be composed of these three metamodels. The definition of abstract syntax metamodels has already standardized approaches (e.g. Ecore\footnote{\url{https://www.eclipse.org/modeling/emf/}}) and thus is mostly ignored. Furthermore, the proposed design currently only supports a render metamodel definition composed of graphic primitives. Complex graphic structures would have to be explored in follow up works. This work focuses on the concrete syntax metamodel, that connects render and abstract syntax and proposes an approach to formalize this connection. The root definition of the \textsc{CouchEdit} configuration metamodel is shown in \Cref{fig:metamodel-base}. throughout the chapter, this root model is gradually being extended with new concepts, until finally all utilized concepts have been introduced (complete metamodel is depicted in \Cref{fig:complete-metamodel}).

\begin{figure}
  \centering
  \includesvg[width=.7\linewidth]{images/"csd - metamodel-base"}
  \caption{Composition of the \textsc{CouchEdit}Configuration metamodel}
  \label{fig:metamodel-base}
\end{figure}

The primary goal of the proposed design is to hide \textsc{CouchEdit}'s complexity behind more accessible metamodel definitions. To this end, multiple concepts are employed, that either abstract away from \textsc{CouchEdit}'s implementation details, or introduce ways to streamline the translation from concrete to abstract representation. Most of these concepts could introduce performance overhead, but as this work focuses on the design aspect, performance analysis and optimization is subsidiary and subject to further research.

\section{Render Metamodel}
\textsc{CouchEdit}'s render syntax is realized as a set of graphic objects. The framework in its current form primarily focuses on primitive graphic objects, with its class structure being derived \cite[p.39]{nachreiner_couchedit_2020} from Bottoni and Grau's work, "A Suite of Metamodels as a Basis for a Classification of Visual Languages" \cite{bottoni_suite_2004}. While the notion of complex graphic objects has been introduced in \textsc{CouchEdit}'s formal definition, the concept for now only exists in theory. This thesis, because of time constraints, does not explore definition of the concrete syntax all to much and instead focuses only on graphic primitives. The employed render syntax metamodel is describe in \Cref{fig:concretesyntax}. As shown, it facilitates a basic structure to define graphic primitives needed for the described visual language. Future works would have to explore, how graphic objects could be customized, by integrating attribute bag definitions as well as complex graphic object definitions, to create custom symbols, better suited for certain modeling languages.

\begin{figure}
  \centering
  \includesvg[width=.5\linewidth]{images/"csd - rendersyntax"}
  \caption{Concrete syntax metamodel used in this thesis}
  \label{fig:concretesyntax}
\end{figure}


\section{Abstract Syntax}
\label{sec:abstract-syntax}
As noted before, the abstract syntax can be defined using existing standards. Nonetheless, the translation metamodel needs to reference the abstract syntax at certain points in this chapter. Therefore, a barebones implementation that is derived from Ecore's own metamodel\footnote{\url{https://download.eclipse.org/modeling/emf/emf/javadoc/2.9.0/org/eclipse/emf/ecore/package-summary.html}} definition is defined here (\Cref{fig:csd-abstractsyntax}). Notable concepts needed in the definition of an abstract syntax, are foremost definition of classes. This includes, definition of class attributes, as well as concepts such as inheritance and references to other classes. Furthermore definition of simple data types as well as enums is required. \comment{(maybe find source that lists requirements for an abstract syntax metamodel to support what ive written here)}

\begin{figure}
  \centering
  \includesvg[width=.7\linewidth]{images/"csd - abstractsyntax"}
  \caption{Used subset implementation of Ecore}
  \label{fig:csd-abstractsyntax}
\end{figure}


\section{Language Concepts}
\label{sec:language-concepts}
the abstract syntax tree usually differs between programing languages \comment{(another statement i should maybe cite?)}. Therefore, when looking at lower level concepts, found in most programming languages (e.g.: arithmetic, branching), their metamodel representation varies while the functionality stays the same. For this reason and because there is already enough documentation on how to specify abstract syntax trees, common language concepts will not be defined, as this depends on the actual language implementation. Instead at points where these language concepts would reside, it is only defined what the given metamodel expects from the implementation and example code snippets are given in an unspecified pseudo language. Despite this, there are certain concepts special to the \textsc{CouchEdit} metamodel, which a language implementation would have to realize. these concepts are presented in the following subsections.


\subsection{Helper Functions}
When defining a translation metamodel, it may become useful to relocate certain procedures or algorithms into separate functions. Reasons for this may be, to access it from multiple points in the definition, to implement a recursive structure or, simply to split up complex parts. Thus the metamodel should provide a facility for the definition of custom functions. That being said, the actual metamodel definition is kept ambiguous, as details depend on the given implementation. In the architecture described here, these helper functions are defined on the highest level of the metamodel and thus are available in all statement blocks, but it would also be feasible to move function definitions into sub scopes, should that provide advantages for certain implementations.

\subsection{Graph Navigation}
\label{sec:abstraction}
Something used a lot in the proposed architecture, is traversal through the hypergraph. It should be possible for the user, to easily get nodes that are adjacent to any given node. In \textsc{CouchEdit}'s architecture, this is handled by separate services (\Cref{sec:services}). This means, that the syntax for reaching a node related by a certain relation type looks something like this:

\begin{lstlisting}[language=customLang, caption={Example on how to get all \texttt{GOs} contained by a given element \texttt{go}, in the \textsc{CouchEdit} architecture}, captionpos=b]
val containedGOs = relationService
      .getAllElementsRelatedFrom(go, Contains) 
\end{lstlisting}

The \texttt{getAllElementsRelatedFrom} function, takes a \texttt{GO} and a relation type and returns all \texttt{GOs} that have a relation of the given type, that points from the given \texttt{GO} to themselves. This and similar helper functions are used repeatedly, thus DSL implementations of the here described architecture should provide some form of abstraction to this service call. In the following code snippets, it is assumed that these functions were masked by member function implementations similar to the following:

\begin{lstlisting}[caption={The \texttt{getAllElementsRelatedFrom} function, implemented as a member function eases navigation through the hypergraph}, captionpos=b]
go.getAllElementsRelatedFrom(Contains)
\end{lstlisting}

Implementation in form of such extension functions allows for a more natural navigation trough the hypergraph, which is especially useful when traversing longer distances which will become apparent in the following sections. A list of these navigation functions can be found in \Cref{app:navigationfunctions}.


\section{Syntax Processors}
The primary concern when defining a modeling language with clear separation between concrete and abstract syntax, is the question on how to connect these two distinct models. In this point, the designed architecture draws inspiration from Fondement and Baar \cite{fondement_making_2005}. The author's proposed idea of connecting abstract und concrete syntax, using \texttt{DisplayManagers}, serves as a basis that can be built upon. This approach consists of two parts, recognition and synchronization.

\subsection{Recognition}
\label{sec:recognition}
The recognition part is concerned with detecting patterns in the graphical syntax that have an abstract syntax representation. For this, Fondement and Baar proposed the introduction of a further abstraction layer. This layer composes the graphic primitives and attributes, which represent a model element, into display classes. But the authors keep possible implementation of this abstraction layer open. Furthermore it did not seem suitable to introduce a further abstraction layer, as most processing in the \textsc{CouchEdit} architecture is applied directly to the concrete syntax hypergraph, thus mapping graphic objects to a new layer would introduce a set of new problems to be solved. Instead the architecture proposed here, arrived at a different approach. For each type of display manager, a set of constraints can be defined on the hypergraph's graphic objects. Whenever a graphic object satisfies all constraints of a given display manager type it is deemed to be the base element of a concrete representation of this display manager type and an instances of this display manager and corresponding model element are created and connected to the graphic object (\Cref{fig:place-recognition}).

% arrived at a different approach. The Metamodel allows for the definition of \texttt{Patterns}. a \texttt{Pattern} possesses a name, as well as a set of constraints. A \texttt{Constraint} checks if a given \texttt{GO} satisfies a certain condition. Each \texttt{GO} in the hypergraph is checked against all constraints of a given pattern. If a GO satisfies all constraints, a given \texttt{Pattern}

\begin{figure}
  \centering
  \includesvg[height=8cm]{images/"visualization - place-recognition"}
  \caption{PlaceRecognitionProcessor, adding PlaceDM to a GraphicObject that satisfies constraints}
  \label{fig:place-recognition}
\end{figure}

These constraints can be defined as simple boolean expressions, that each graphic object in the hypergraph, is checked against. The constraints for a place element, could be defined as follows:

\begin{lstlisting}[language=OCL,caption={Possible constraints to detect GOs representing a place},captionpos=b]
go.shape is Circle
go.allRelatedTo(Contains).isEmpty()
\end{lstlisting}

These constraints first check if the given GO has the shape of a circle. If that is true, it is also checked if the given GO has any \texttt{Contains} relations pointing toward itself. If that is the case, the given circle is contained by another element and thus not clearly identifiable as a place, as it could also possibly represent a token. A corresponding definition for transitions could look as follows:

\begin{lstlisting}[captionpos=b,caption={Simple constraint to check for transition representations},label={lst:transition-constraints}]
go.shape is Rectangle
\end{lstlisting}

These are barebones requirements to identify graphical representations and they could be extended by any amount of further constraints to increase the amount of specificity required from the concrete instance.

\subsection{Synchronization}
With the recognition part in place, it is possible to detect graphical representations and attach corresponding abstract instances. Now the synchronization part is responsible to make sure, abstract and concrete representation reflect the same state. To this end, the metamodel allows for the definition of rules on a \texttt{DisplayManager}. This step was explained in detail in \cite{fondement_making_2005}. Fondement and Baar propose the usage of OCL invariants as a language for defining these rules. But as the here defined approach does not implement the display class abstraction layer, the concrete representation has to be queried directly. Furthermore, implementing OCL invariants is not necessary and synchronizations could also be handled by assignment statements, which is done in the following. For a place element there are four aspects that have to be synced:

\begin{enumerate}
  \item Name of the given place
  \item Number of Tokens this place has
  \item Incoming transitions
  \item Outgoing transitions
\end{enumerate}

Reliably determining a place's name poses some special challenges and requires further concepts, introduced later. Determining the token number, on the other hand is easily implemented using the given tools. A simple rule that syncs this attribute could look something like this:

\begin{lstlisting}[captionpos=b,caption={Rule that syncs the token count of a place element}]
dm.me.tokens = dm.go
                  .allRelatedFrom(Contains)
                  .select(go -> go.shape is Circle)
                  .count()
\end{lstlisting}

This statement ensures that the token attribute of the model element is always equal to the number of all GOs with the shape Circle, that are contained by the base graphic object. In a similar fashion, incoming and outgoing transitions can be defined:
\begin{lstlisting}[captionpos=b,caption={Rule that syncs incoming transitions of a place element},label={lst:incoming-transitions}]
dm.me.incoming = 
      dm.go
          .allRelatedTo(ConnectionEnd,
              rel -> rel.isEndConnection)
          .select(go -> go.shape is Line)
          .collect(go -> go.relatedFrom(ConnectionEnd))
          .select(go -> go.shape is Rectangle)
          .select(go -> go.dm != null)
          .collect(go -> go.dm.me)
\end{lstlisting}

This statement ensures that all transitions, connected to the given DM's GO, by a line, are composed into the list of incoming transitions (\Cref{fig:incoming-sync}). This exhibits the usual approach to syncing concrete and abstract representation.

% Starting from a \texttt{DisplayManager}, the statements query along a path of relations and elements, to determine the correct state of a model element.

\begin{figure}
  \centering
  \includesvg[height=7.5cm]{images/"visualization - incoming-sync"}
  \caption{A connection line is added to the graph and the PlaceSyncProcessor updates the Place model element}
  \label{fig:incoming-sync}
\end{figure}

\subsection{metamodel}
The resulting sub model for this area of the configuration would look as described in \Cref{fig:initial-syntax-model}. The depicted Metamodel allows for the definition of \texttt{DisplayManagers}. A \texttt{DisplayManager} definition, needs a reference model element type from the abstract syntax metamodel. The corresponding DisplayManager can then be inferred from this element. Furthermore, the \texttt{DisplayManager} definition, needs \texttt{Constraints} and \texttt{Rules}. The \texttt{constraints}, are then used by a RecognitionProcessor, to add instances of the inferred \texttt{DisplayManager}. On the other hand \texttt{Rules} are then used by a DisplayManagerProcessor, to keep model elements aligned. As stated, it would be possible to define \texttt{Constraints} and \texttt{Rules} as OCL invariants, similar to what Fondement and Baar did. Another possible implementation would be as statement blocks, where \texttt{Constraints} return boolean values and \texttt{Rules} utilize assignment statements, which would be similar to the here described code snippets. This is not the final iteration of this metamodel as will be shown in the next section.

\begin{figure}
  \centering
  \includesvg[width=.7\linewidth]{images/"csd - initial-syntaxprocess-model"}
  \caption{First Design of the \texttt{DisplayManager} metamodel}
  \label{fig:initial-syntax-model}
\end{figure}


\section{Pattern System}
When assessing the incoming transition rule (\Cref{lst:incoming-transitions}), it becomes apparent that checking if the connected \texttt{GO} represents a transition has to be done manually. In the given example, checking if the \texttt{GO} represents a transitions is no big task as transition recognition is handled with only one constraint (\Cref{lst:transition-constraints}), but when regarding model elements with multiple constraints, this can become a repetitive and inefficient task.

To alleviate this problem, the proposed architecture introduces a Pattern system. A Pattern can mark elements of the graph, as satisfying a certain set of constraints. A \texttt{Pattern} is, similar to \texttt{AttributeBags}, a separate element in the graph, that is connected to the element it describes, with a relation. It has a single value attribute, that indicates its name. Identical to \texttt{DisplayManager} definitions, described in the last section, pattern definitions take a set of constraints. Every Element in the graph is then checked against these \texttt{Constraints} and if the Element satisfies all of them, the pattern is added to the given Element. This behavior is depicted in \Cref{fig:kind-recognition} for an example transition \texttt{Pattern}.

\begin{figure}
  \centering
  \includesvg[height=7.5cm]{images/"visualization - kind-recognition"}
  \caption{\texttt{TransitionPatternProcessor} detects a \texttt{GO} that satisfies constraints and adds \texttt{PatternType}}
  \label{fig:kind-recognition}
\end{figure}

The similarity to the \texttt{DisplayManager} recognition part means that it can actually replace this part, which is done in this concept. Instead of checking \texttt{Constraints} themselves, \texttt{DisplayManager} recognition processors just check if a given GO has a certain pattern type attached and if this is true, the corresponding \texttt{DisplayManager} is added. As shown in \Cref{fig:Transition-Kind-Recognition}, when a \texttt{GO}, representing a transition is added, the \texttt{TransitionPatternProcessor}, first adds an \texttt{PatternType} with the value \texttt{Transition}. The \texttt{TransitionRecognitionProcessor} then checks the \texttt{GO} which now matches the \texttt{Transition} pattern and thus adds a \texttt{TransitionDM}.

\begin{figure}[ht]
  \centering
  \includesvg[height=11cm]{images/"visualization - Transition-Kind-Recognition"}
  \caption{\texttt{TransitionRecognitionProcessor} adds DM after the \texttt{TransitionPatternProcessor} has added a transition \texttt{Pattern}}
  \label{fig:Transition-Kind-Recognition}
\end{figure}

With the definition of a convenience member function that checks if an element has a given pattern, the the rule, syncing incoming transitions, can now be rewritten as follows:
\begin{lstlisting}[captionpos=b,caption={Improved incoming transition rule, that also filters for elements with a that match the \texttt{Transition} pattern.}]
dm.me.incoming = 
    dm.go
        .allRelatedTo(ConnectionEnd,
            rel -> rel.isEndConnection)
        .select(go -> go.shape is Line)
        .collect(go -> go.relatedFrom(ConnectionEnd))
        .select(go -> go.hasPattern(Transition))
        .collect(go -> go.dm.me)
\end{lstlisting}


It is important to note that the \texttt{Pattern} system isn't exclusive to \texttt{GOs} that have an abstract representation. For \texttt{GOs} with a corresponding \texttt{DisplayManager}, the \texttt{DM} type can just be checked to find out if it connects a model elements of a certain type. Rather, the pattern system can also be used to recognize all sorts of patterns in the graph, that would otherwise have to be checked repeatedly. For example. it could be used to define a stricter check, on what element in a Petrinet Graph represents a token.

\subsection{Metamodel}
As mentioned in the last section, because of the introduction of the pattern system, the \texttt{DisplayManager} definition model has to be revised. Instead of possessing a set of constraints, \texttt{DisplayManager} definitions now have a reference to a \texttt{Pattern} (\Cref{fig:revised-syntax-model}).

\begin{figure}
  \centering
  \includesvg[width=.75\linewidth]{images/"csd - revised-syntaxprocess-model"}
  \caption{Revised SyntaxProcessor metamodel that now includes the Pattern system}
  \label{fig:revised-syntax-model}
\end{figure}


\section{Plugins}
\label{sec:plugins}
While the invariant for incoming transitions, is sufficient for an initial example, it has two major flaws. Firstly, it is not checking if the connecting line has an arrow end. Secondly only lines that are drawn from the transition towards the place, are treated as incoming lines, as noted in \Cref{sec:core-processors}. Fixing these issues in form of a rule would be too verbose for such a common pattern.

For this reason, the plugin system is introduced. Plugins are predefined processors that process specific parts of the hypergraph. These processing areas are not as integral as the ones solved by the core processors and thus are opt-in. Furthermore certain plugin processors can be configured which allows them to cover a wider field of use cases. One example of such a plugin would be the \texttt{ConnectionProcessor}. It looks for line \texttt{GOs} and checks if they connect two other \texttt{GOs}. If that's the case, the processor adds either a \texttt{ConnectionTo} relation or a \texttt{ConnectionBetween} relation (\Cref{fig:transition-plugin}), depending on if the line's arrow ends indicate a directed or undirected connection. Adding this plugin allows for a final rewrite of the rule, syncing incoming transitions:

\begin{lstlisting}[captionpos=b,caption={Final iteration of the place incoming transition rule}]
dm.me.incoming = 
    dm.go
        .allRelatedTo(ConnectionTo)
        .select(go -> go.hasPattern(Transition))
        .collect(go -> go.dm.me)
\end{lstlisting}

\begin{figure}[ht]
  \centering
  \includesvg[height=7.5cm]{images/"visualization - transition-plugin"}
  \caption{\texttt{ConnectionProcessor} adds \texttt{ConnectionTo} relation on detecting a directed line}
  \label{fig:transition-plugin}
\end{figure}



\subsection{Label Processor}
Defining a transformation to sync a place's name has been postponed until now, because it poses multiple new challenges. When determining, if a label represents the name of a place object, multiple aspects have to be minded:
\begin{enumerate}
  \item How close is the label to the place.
  \item Are different \texttt{GOs} in the proximity that could be associated with this label.
  \item Are there other labels that could represent the name of this place.
\end{enumerate}

While possible, checking all these conditions in a syncing statement would require several dozen lines of code. Furthermore it would cause a lot of overhead. For every place, whenever syncing its state, the relation possibility to all labels has to be calculated. If one label is a potential candidate, it also has to be calculated if the label could be a possible candidate for another element. Thus, the idea of building a plugin that handles these calculations arises.

The basic idea of the \texttt{LabelProcessor} is, to add \texttt{LabelFor} relations from labels to other graphic objects. Furthermore the \texttt{probability} attribute is utilized to define how probable it is, that this the intended label association. To be applicable to multiple concrete syntaxes, this plugin poses a new set of requirements:
\begin{description}
  \item[Requirement 1:] Modeling syntaxes require different spatial relations between label and graphic object (label can be contained, surrounding, above/below, etc.).
  \item[Requirement 2:] Different \texttt{GO} shapes require different algorithms to calculate the probability (proximity to a circle cant be calculated the same way as proximity to a rectangle is)
        % \item multiple LabelFor relations from a single Label should be able to influence the probability of these relations.
  \item[Requirement 3:] Not every \texttt{GO} needs a label. For example, in the Petrinets syntax, only \texttt{GOs} representing either a place or transition, require a label.
  \item[Requirement 4:]  Some label relations can take precedence over others. For example, in Statecharts, a label contained by a simple state, cannot describe a transition trigger event.
\end{description}

\subsubsection{Label Sub Processor}
The \texttt{LabelProcessor}, implements a set of sub processors. Each sub processor is responsible for different types of calculations. For example, the \texttt{CircleOuterLabel} sub processor calculates the \texttt{LabelFor} relation between a circle \texttt{GO} and a label \texttt{GO} that is placed somewhere outside the circle \texttt{GO} \comment{rewrite sentence}. This means, for every combination of primitive shape and spatial relation, a different sub processor is needed. Each sub processor takes an pattern type and a label. It then finds all graphic objects with its designated shape type and filters them by the given pattern type. The resulting \texttt{GOs} then receive a \texttt{LabelFor} relation from the given label, with a probability calculated by an algorithm implemented in the sub processor.

\subsubsection{Label ProcessingChain}
When regarding requirement 4 it becomes clear that simply enabling the sub processors, needed for a given modeling syntax, isn't enough. A mechanism is needed that allows for different sub processor configurations to influence each other. Therefore the concept of a ProcessorChain was introduced (\Cref{fig:labelprocessor-config}). A \texttt{ProcessorChain} allows for the configuration of sub processors by introducing an arithmetic like operation system. Processor chains can either be \texttt{Operations} or \texttt{Terminals}. Terminals represent either a sub processor or nothing. An operation on the other hand defines a link between two Processor chains. Operations possess an \texttt{Operator} that defines how the results of the left hand processing chain should affect the results of the right one. For example, the `and` Operator defines that both processing chains are calculated normally. On the other hand, the `ifEmpty` operator only calculates the right processor chain, if the left one has returned no values. The `ifAmbiguous` operator ignores the left chain if more than one relation is returned and instead calculates the right side. Using this ProcessorChain, the label processing for Petrinets could be configured as following:
\begin{lstlisting}
(CircleOuterLabel(Place) and 
RectangleOuterLabel(Transition)) ifAmbiguous Nothing
\end{lstlisting}
This causes the \texttt{LabelProcessor} to calculate outer proximity \texttt{LabelFor} relations for all circular \texttt{GOs} with pattern type \texttt{Place} and rectangular\texttt{GOs} with pattern type \texttt{Transition}. should this calculation return more than one possible relation for a given label, the relations are ignored and nothing is returned instead.

\begin{figure}[ht]
  \centering
  \includesvg[width=\linewidth]{images/"csd - labelprocessor"}
  \caption{Class diagram describing the LabelProcessor's configuration metamodel}
  \label{fig:labelprocessor-config}
\end{figure}

This \texttt{LabelProcessor} plugin is by no means a perfect implementation for the given problem, rather it provides a general idea of the purpose and applicability for the plugin system, as well as an idea of how specialized the definition of plugin configurations can become. The requirements of plugin configurations, forces DSL implementations of this metamodel to potentially be updated every time a new plugin with custom configuration is added to the system. Alternatively an approach for more general plugin configuration has to be explored


\subsection{Summary}
\comment{todo}

In this chapter, the developed metamodel was introduced step by step. The base idea for this metamodel was derived from Fondement and Baar \cite{fondement_making_2005}, but was partially modified and extended to serve requirements posed by the \textsc{CouchEdit} architecture. The complete metamodel is depicted in \Cref{fig:complete-metamodel}.