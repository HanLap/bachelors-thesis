\chapter{Design Concept}
\label{chap:design}
The proposed artifact effectively is a form of triple graph grammar, meaning it specifies a source model (concrete syntax), a target model (abstract syntax) and a third translation metamodel. The definition of abstract syntax metamodel has already standardized approaches (e.g. Ecore\footnote{\url{https://www.eclipse.org/modeling/emf/}}) and thus is mostly ignored. Furthermore, the proposed design currently only supports a concrete syntax definition composed of graphic primitives, thus complex graphic structures would have to be explored in follow up works. This work focuses on the translation metamodel, that connects concrete and abstract syntax and produces one approach to handling this connection.

The primary goal of the proposed design is to reduce complexity of the CouchEdit framework. To this end, multiple strategies are employed, that either abstract away from CouchEdits implementation details, or introduce ways to streamline the translation from concrete to abstract syntax. Most of these strategies introduce performance overhead, but as this work focuses on the design aspect, performance analysis is also subject to further research. 

\section{Abstraction}
Abstraction important because distances user from implementation details



Graph traversal: 

\begin{itemize}
  \item Graph traversal
  \item utility functions
\end{itemize}



\section{Syntax Processors}
The primary concern when defining a modeling language with clear separation between concrete and abstract syntax, is the question on how to connect these two distinct models. In this point, the designed architecture draws inspiration from Fondement and Baar \cite{fondement_making_2005}. The authors proposed idea of connecting abstract und concrete syntax, using DisplayManagers, serves as a basis that can be built upon. This approach consists of two parts, recognition and synchronization. 

\subsection{Recognition}
The recognition part is concerned with detecting patterns in the concrete syntax that have an abstract syntax representation. For this, fondement and baar proposed the introduction of a further abstraction layer, that composes the graphic primitives and attributes, representing a model element, into display classes. But the Author's keep possible implementation of this abstraction layer open. Furthermore it did not seem necessary to create further abstraction in the CouchEdit architecture \comment{why}. Instead the architecture proposed here, tries a different Approach. For each type of DisplayManager, a set of constraints can be defined on the hypergraph's graphic objects. Whenever a graphic object satisfies all constraints of a given display manager type it is deemed to be a concrete representation of this display manager type and an instances of this display manager class and corresponding model element type are created and connected to the graphic object (fig. \ref{fig:place-recognition}). 

\begin{figure}
  \centering
  \includegraphics[height=8cm]{images/"visualization - place-recognition"}
  \caption{PlaceRecognitionProcessor, adding PlaceDM to a GraphicObject that satisfies constraints}
  \label{fig:place-recognition}
\end{figure}

These constraints can be defined as simple Boolean expressions, that are applied to every graphic object in the graph. The constraints for a Place element, could be defined as follows: 

\begin{lstlisting}[language=OCL]
  self.shape is Circle
  self.allRelatedTo(Contains).isEmpty()
\end{lstlisting} 

These constraints first check if the given GO has the shape of a circle. If that is true, it is also checked if the given GO has any contains relations pointing toward itself. If that is the case, the given circle is contained by another element and thus not clearly identifiable as a Place, as it could also possibly represent a token. A corresponding definition for Transitions could look as following: 

\begin{lstlisting}
  self.shape is Rectangle
\end{lstlisting}

These are barebones requirements to identify concrete syntax representations and they could be extended by any amount of further constraints, to increase the amount of specificity required by the concrete definition.

\subsection{Synchronization}
The Synchronization part is now responsible to make sure, the abstract syntax elements attributes align with the concrete state. This step was explained in detail in \cite{fondement_making_2005}. Fondement and baar propose the usage of OCL Invariants as a mechanism for synchronization. But as the here defined approach does not implement the display class abstraction layer, the concrete representation has to be queried directly. For a Place element there are four aspects that have to be synced:
\begin{enumerate}
  \item Name of the given Place
  \item Number of Tokens this place has
  \item Incoming transitions
  \item Outgoing transitions
\end{enumerate} 

Reliably determining a Places name poses some special challenges and requires further concepts, introduced later. Determining the token number, on the other hand is easily implemented using the given tool. Following the OCL syntax proposed by Fondement and Baar, an invariant syncing this attribute could look something like this:
\begin{lstlisting}[language=OCL]
  context PlaceDM: 
  inv: self.me.tokens = self.go
                            .allRelatedFrom(Contains)
                            .select(go | go.shape is Circle)
                            .count()
\end{lstlisting}

This invariant ensures that the token attribute of the model element is always equal to the number of all GOs with the shape Circle, that are contained by our base graphic object. In a similar fashion, incoming and outgoing Transitions can be defined:
\begin{lstlisting}[language=OCL]
  context PlaceDM: 
  inv:  self.me.incoming = 
            self.go
                .allRelatedTo(ConnectionEnd, 
                    rel | rel.isEndConnection)
                .select(go | go.shape is Line)
                .collect(go | go.relatedFrom(ConnectionEnd))
                .select(go | go.shape is Rectangle)
                .select(go | go.dm <> null)
                .collect(go | go.dm.me.ref())
\end{lstlisting}

This invariant ensures that all Transitions, connected to the given Place, by a line are added to the list of incoming Transitions (fig. \ref{fig:incoming-sync}). This exhibits the usual approach to syncing concrete and abstract syntax. Starting from a DisplayManager, the processors searches along a path of relations and elements, to determine the correct state of a model element.

% What immediately becomes clear is, that the model element side of the invariant is always relatively simple, while querying the concrete syntax and the existing relations can grow in complexity fast. 

\begin{figure}
  \centering
  \includegraphics[height=7.5cm]{images/"visualization - incoming-sync"}
  \caption{A connection line is added to the graph and the PlaceSyncProcessor updates the Place model element}
  \label{fig:incoming-sync}
\end{figure}


\section{Kind System}

When assessing the Incoming Transition Invariant, defined in the last section, it becomes apparent that checking if the connected GO represents a Transition has to be done manually. In the given example, checking if the GO represents a Transitions is no big task as Transition recognition is handled with only one constraint, but when regarding model elements with multiple constraints, this can become a repetitive and inefficient task. 

To Alleviate this problem, the proposed architecture introduces a kind system. A Kind is a sort of meta type, that annotates Elements in the graph, to give further information about their purpose. A Kind is, similar to AttributeBags, a separate Element in the Graph, that is Connected to the Element it annotates, with a relation. It has a single value Attribute, das indicates its purpose. In the same way as the syntax recognition part, the kind system takes a set of constraints for a given kind. Every Element in the graph is then checked against these constraints and if the Element satisfies all of them, the Kind is added to the given Element. This behavior is depicted in fig. \ref{fig:kind-recognition}.

\begin{figure}
  \centering
  \includegraphics[height=7.5cm]{images/"visualization - kind-recognition"}
  \caption{TransitionKindProcessor detects a GO that satisfies constraints and adds KindElement}
  \label{fig:kind-recognition}
\end{figure}

The similarity To the syntax recognition part means that it can actually replace this part, which is done in this Concept. Instead of checking all constraints themselves, syntax recognition processors, only just check if a given GO has a certain Kind and if this is true, the corresponding DisplayManager is added. As shown in figure \ref{fig:Transition-Kind-Recognition}, when a GO, representing a Transition is added, the TransitionKindProcessor, first adds a Kind with the value Transition, the TransitionRecognitionProcessor, then finds the GO that now has a Transition Kind and adds the corresponding Transition DisplayManager.

\begin{figure}[ht]
\centering
\includegraphics[height=11cm]{images/"visualization - Transition-Kind-Recognition"}
\caption{TransitionRecognitionProcessor adds DM after the TransitionKindProcessor has added a Transition Kind}
\label{fig:Transition-Kind-Recognition}
\end{figure}

with the definition of a convenience member function that checks if an Element has a given Kind, the Place incoming transition invariant can now be rewritten as follows: 
\begin{lstlisting}[language=OCL]
  context PlaceDM: 
  inv:  self.me.incoming = 
            self.go
                .allRelatedTo(ConnectionEnd, 
                    rel | rel.isEndConnection)
                .select(go | go.shape is Line)
                .collect(go | go.relatedFrom(ConnectionEnd))
                .select(go | go.hasKind(Transition))
                .collect(go | go.dm.me.ref())
\end{lstlisting}


It is important to note that the Kind system isn't exclusive to GOs that have an abstract representation. For GO's with a corresponding DisplayManager, the type of this DM can just be checked to find out if it connects a model element one is interested in. But the Kind System can be used to recognize all sorts of patterns in the Graph, that would otherwise have to be checked repeatedly.

\section{Plugins}

While the invariant for incoming transitions, is sufficient for an initial example, it has two mayor flaws. Firstly, it is not checking if the connecting line has an arrow end and secondly only lines that are drawn from the Transition towards the Place, are treated as incoming lines, which is defined by the isEndConnection attribute of the ConnectionEnd relation. Fixing these issues in form of an invariant, would be to verbose vor such a common Pattern.

For this reason, a Plugin system is introduced. Plugins are predefined Processors that process specific parts of the Hypergraph. These processing areas are not as integral as the ones solved by the core processors and thus are opt-in. Furthermore certain plugin processors, can be configured which allows them to be suited to certain tasks. One Example of such a plugin would be the TransitionProcessor. It looks for line GraphicObjects and checks if they connect two other GOs. If that's the case, the Processors adds either a TransitionTo relation or a TransitionBetween relation (fig. \ref{fig:transition-plugin}), depending on if the line's ArrowEnds indicate a directed or undirected Transition. Adding this Plugin allows for a final rewrite of the incoming transitions invariant:

\begin{lstlisting}[language=OCL]
  context PlaceDM: 
  inv:  self.me.incoming = 
            self.go
                .allRelatedTo(TransitionTo)
                .select(go | go.hasKind(Transition))
                .collect(go | go.dm.me.ref())
\end{lstlisting}

\begin{figure}
\centering
\includegraphics[height=7.5cm]{images/"visualization - transition-plugin"}
\caption{TransitionProcessors adds TransitionTo relation on detecting a directed line}
\label{fig:transition-plugin}
\end{figure}

\subsection{Label Processor}




\section{Metamodel}


   


\begin{itemize}
  \item abstraction (implemented with extension functions)
  \item OCL like syntax to navigate tree
  \item Graph Transformations 
  \item forcing the user to draw clear graphs
  \item transformation precondition heavy, post condition easy
\end{itemize}